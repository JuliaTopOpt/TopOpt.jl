var documenterSearchIndex = {"docs":
[{"location":"reference/TopOptProblems/#TopOptProblems","page":"TopOptProblems","title":"TopOptProblems","text":"","category":"section"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"This sub-module of TopOpt defines a number of standard topology optimization problems for the convenient testing of algorithms.","category":"page"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"CurrentModule = TopOpt.TopOptProblems","category":"page"},{"location":"reference/TopOptProblems/#Problem-types","page":"TopOptProblems","title":"Problem types","text":"","category":"section"},{"location":"reference/TopOptProblems/#Abstract-type","page":"TopOptProblems","title":"Abstract type","text":"","category":"section"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"StiffnessTopOptProblem is an abstract type that a number of linear elasticity, quasi-static, topology optimization problems subtype.","category":"page"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"StiffnessTopOptProblem","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.StiffnessTopOptProblem","page":"TopOptProblems","title":"TopOpt.TopOptProblems.StiffnessTopOptProblem","text":"abstract type StiffnessTopOptProblem{dim, T} <: AbstractTopOptProblem end\n\nAn abstract stiffness topology optimization problem. All subtypes must have the following fields:\n\nch: a JuAFEM.ConstraintHandler struct\nmetadata: Metadata having various cell-node-dof relationships\nblack: a BitVector of length equal to the number of elements where black[e] is 1 iff the e^th element must be part of the final design\nwhite:  a BitVector of length equal to the number of elements where white[e] is 1 iff the e^th element must not be part of the final design\nvarind: an AbstractVector{Int} of length equal to the number of elements where varind[e] gives the index of the decision variable corresponding to element e. Because some elements can be fixed to be black or white, not every element has a decision variable associated.\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#Test-problems","page":"TopOptProblems","title":"Test problems","text":"","category":"section"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"The following types are all concrete subtypes of StiffnessTopOptProblem. PointLoadCantilever is a cantilever beam problem with a point load as shown below. HalfMBB is the half Messerschmitt-Bölkow-Blohm (MBB) beam problem commonly used in topology optimization literature. LBeam and TieBeam are the common L-beam and tie-beam test problem used in topology optimization literature. The PointLoadCantilever and HalfMBB problems can be either 2D or 3D depending on the type of the inputs to the constructor. If the number of elements and sizes of elements are 2-tuples, the problem constructed will be 2D. And if they are 3-tuples, the problem constructed will be 3D. For the 3D versions, the point loads are applied at approximately the mid-depth point. The TieBeam and LBeam problems are always 2D.","category":"page"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"PointLoadCantilever\nPointLoadCantilever(::Type{Val{CellType}}, nels::NTuple{dim,Int}, sizes::NTuple{dim}, E, ν, force) where {dim, CellType}","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.PointLoadCantilever","page":"TopOptProblems","title":"TopOpt.TopOptProblems.PointLoadCantilever","text":"///**********************************\n///*                                *\n///*                                * |\n///*                                * |\n///********************************** v\n\n\n@params struct PointLoadCantilever{dim, T, N, M} <: StiffnessTopOptProblem{dim, T}\n    rect_grid::RectilinearGrid{dim, T, N, M}\n    E::T\n    ν::T\n    ch::ConstraintHandler{<:DofHandler{dim, <:Cell{dim,N,M}, T}, T}\n    force::T\n    force_dof::Integer\n    black::AbstractVector\n    white::AbstractVector\n    varind::AbstractVector{Int}\n    metadata::Metadata\nend\n\ndim: dimension of the problem\nT: number type for computations and coordinates\nN: number of nodes in a cell of the grid\nM: number of faces in a cell of the grid\nrect_grid: a RectilinearGrid struct\nE: Young's modulus\nν: Poisson's ration\nforce: force at the center right of the cantilever beam (positive is downward)\nforce_dof: dof number at which the force is applied\nch: a JuAFEM.ConstraintHandler struct\nmetadata: Metadata having various cell-node-dof relationships\nblack: a BitVector of length equal to the number of elements where black[e] is 1 iff the e^th element must be part of the final design\nwhite:  a BitVector of length equal to the number of elements where white[e] is 1 iff the e^th element must not be part of the final design\nvarind: an AbstractVector{Int} of length equal to the number of elements where varind[e] gives the index of the decision variable corresponding to element e. Because some elements can be fixed to be black or white, not every element has a decision variable associated.\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.PointLoadCantilever-Union{Tuple{CellType}, Tuple{dim}, Tuple{Type{Val{CellType}},Tuple{Vararg{Int64,dim}},Tuple{Vararg{T,dim}} where T,Any,Any,Any}} where CellType where dim","page":"TopOptProblems","title":"TopOpt.TopOptProblems.PointLoadCantilever","text":"PointLoadCantilever(::Type{Val{CellType}}, nels::NTuple{dim,Int}, sizes::NTuple{dim}, E, ν, force) where {dim, CellType}\n\ndim: dimension of the problem\nE: Young's modulus\nν: Poisson's ration\nforce: force at the center right of the cantilever beam (positive is downward)\nnels: number of elements in each direction, a 2-tuple for 2D problems and a 3-tuple for 3D problems\nsizes: the size of each element in each direction, a 2-tuple for 2D problems and a 3-tuple for 3D problems\nCellType: can be either :Linear or :Quadratic to determine the order of the geometric and field basis functions and element type. Only isoparametric elements are supported for now.\n\nExample:\n\nnels = (60,20);\nsizes = (1.0,1.0);\nE = 1.0;\nν = 0.3;\nforce = 1.0;\n\n# Linear elements and linear basis functions\ncelltype = :Linear\n\n# Quadratic elements and quadratic basis functions\n#celltype = :Quadratic\n\nproblem = PointLoadCantilever(Val{celltype}, nels, sizes, E, ν, force)\n\n\n\n\n\n","category":"method"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"HalfMBB\nHalfMBB(::Type{Val{CellType}}, nels::NTuple{dim,Int}, sizes::NTuple{dim}, E, ν, force) where {dim, CellType}","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.HalfMBB","page":"TopOptProblems","title":"TopOpt.TopOptProblems.HalfMBB","text":" |\n |\n v\nO*********************************\nO*                               *\nO*                               *\nO*                               *\nO*********************************\n                                 O\n\nstruct HalfMBB{dim, T, N, M} <: StiffnessTopOptProblem{dim, T}\n    rect_grid::RectilinearGrid{dim, T, N, M}\n    E::T\n    ν::T\n    ch::ConstraintHandler{<:DofHandler{dim, <:Cell{dim,N,M}, T}, T}\n    force::T\n    force_dof::Integer\n    black::AbstractVector\n    white::AbstractVector\n    varind::AbstractVector{Int}\n    metadata::Metadata\nend\n\ndim: dimension of the problem\nT: number type for computations and coordinates\nN: number of nodes in a cell of the grid\nM: number of faces in a cell of the grid\nrect_grid: a RectilinearGrid struct\nE: Young's modulus\nν: Poisson's ration\nforce: force at the top left of half the MBB (positive is downward)\nforce_dof: dof number at which the force is applied\nch: a JuAFEM.ConstraintHandler struct\nmetadata: Metadata having various cell-node-dof relationships\nblack: a BitVector of length equal to the number of elements where black[e] is 1 iff the e^th element must be part of the final design\nwhite:  a BitVector of length equal to the number of elements where white[e] is 1 iff the e^th element must not be part of the final design\nvarind: an AbstractVector{Int} of length equal to the number of elements where varind[e] gives the index of the decision variable corresponding to element e. Because some elements can be fixed to be black or white, not every element has a decision variable associated.\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.HalfMBB-Union{Tuple{CellType}, Tuple{dim}, Tuple{Type{Val{CellType}},Tuple{Vararg{Int64,dim}},Tuple{Vararg{T,dim}} where T,Any,Any,Any}} where CellType where dim","page":"TopOptProblems","title":"TopOpt.TopOptProblems.HalfMBB","text":"HalfMBB(::Type{Val{CellType}}, nels::NTuple{dim,Int}, sizes::NTuple{dim}, E, ν, force) where {dim, CellType}\n\ndim: dimension of the problem\nE: Young's modulus\nν: Poisson's ration\nforce: force at the top left of half the MBB (positive is downward)\nnels: number of elements in each direction, a 2-tuple for 2D problems and a 3-tuple for 3D problems\nsizes: the size of each element in each direction, a 2-tuple for 2D problems and a 3-tuple for 3D problems\nCellType: can be either :Linear or :Quadratic to determine the order of the geometric and field basis functions and element type. Only isoparametric elements are supported for now.\n\nExample:\n\nnels = (60,20);\nsizes = (1.0,1.0);\nE = 1.0;\nν = 0.3;\nforce = -1.0;\n\n# Linear elements and linear basis functions\ncelltype = :Linear\n\n# Quadratic elements and quadratic basis functions\n#celltype = :Quadratic\n\nproblem = HalfMBB(Val{celltype}, nels, sizes, E, ν, force)\n\n\n\n\n\n","category":"method"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"LBeam\nLBeam(::Type{Val{CellType}}, ::Type{T}=Float64; length = 100, height = 100, upperslab = 50, lowerslab = 50, E = 1.0, ν = 0.3, force = 1.0) where {T, CellType}","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.LBeam","page":"TopOptProblems","title":"TopOpt.TopOptProblems.LBeam","text":"////////////\n............\n.          .\n.          .\n.          . \n.          .                    \n.          ......................\n.                               .\n.                               . \n.                               . |\n................................. v\n                                force\n\nstruct LBeam{T, N, M} <: StiffnessTopOptProblem{2, T}\n    E::T\n    ν::T\n    ch::ConstraintHandler{<:DofHandler{2, <:Cell{2,N,M}, T}, T}\n    force::T\n    force_dof::Integer\n    black::AbstractVector\n    white::AbstractVector\n    varind::AbstractVector{Int}\n    metadata::Metadata\nend\n\nT: number type for computations and coordinates\nN: number of nodes in a cell of the grid\nM: number of faces in a cell of the grid\nE: Young's modulus\nν: Poisson's ration\nforce: force at the center right of the cantilever beam (positive is downward)\nforce_dof: dof number at which the force is applied\nch: a JuAFEM.ConstraintHandler struct\nmetadata: Metadata having various cell-node-dof relationships\nblack: a BitVector of length equal to the number of elements where black[e] is 1 iff the e^th element must be part of the final design\nwhite:  a BitVector of length equal to the number of elements where white[e] is 1 iff the e^th element must not be part of the final design\nvarind: an AbstractVector{Int} of length equal to the number of elements where varind[e] gives the index of the decision variable corresponding to element e. Because some elements can be fixed to be black or white, not every element has a decision variable associated.\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.LBeam-Union{Tuple{Type{Val{CellType}}}, Tuple{CellType}, Tuple{T}, Tuple{Type{Val{CellType}},Type{T}}} where CellType where T","page":"TopOptProblems","title":"TopOpt.TopOptProblems.LBeam","text":"LBeam(::Type{Val{CellType}}, ::Type{T}=Float64; length = 100, height = 100, upperslab = 50, lowerslab = 50, E = 1.0, ν = 0.3, force = 1.0) where {T, CellType}\n\nT: number type for computations and coordinates\nE: Young's modulus\nν: Poisson's ration\nforce: force at the center right of the cantilever beam (positive is downward)\nlength, height, upperslab and lowerslab are explained in LGrid.\nCellType: can be either :Linear or :Quadratic to determine the order of the geometric and field basis functions and element type. Only isoparametric elements are supported for now.\n\nExample:\n\nE = 1.0;\nν = 0.3;\nforce = 1.0;\n\n# Linear elements and linear basis functions\ncelltype = :Linear\n\n# Quadratic elements and quadratic basis functions\n#celltype = :Quadratic\n\nproblem = LBeam(Val{celltype}, E = E, ν = ν, force = force)\n\n\n\n\n\n","category":"method"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"TieBeam\nTieBeam(::Type{Val{CellType}}, ::Type{T} = Float64, refine = 1, force = T(1); E = T(1), ν = T(0.3)) where {T, CellType}","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.TieBeam","page":"TopOptProblems","title":"TopOpt.TopOptProblems.TieBeam","text":"                                                               1\n                                                               \n                                                              OOO\n                                                              ...\n                                                              . .\n                                                           4  . . \n                                30                            . .   \n/ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <-\n/ .                                                                 . <- 2 f \n/ .    3                                                            . <- \n/ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <-\n                                                              ^^^\n                                                              |||\n                                                              1 f\n\nstruct TieBeam{T, N, M} <: StiffnessTopOptProblem{2, T}\n    E::T\n    ν::T\n    force::T\n    ch::ConstraintHandler{<:DofHandler{2, N, T, M}, T}\n    black::AbstractVector\n    white::AbstractVector\n    varind::AbstractVector{Int}\n    metadata::Metadata\nend\n\nT: number type for computations and coordinates\nN: number of nodes in a cell of the grid\nM: number of faces in a cell of the grid\nE: Young's modulus\nν: Poisson's ration\nforce: force at the center right of the cantilever beam (positive is downward)\nch: a JuAFEM.ConstraintHandler struct\nmetadata: Metadata having various cell-node-dof relationships\nblack: a BitVector of length equal to the number of elements where black[e] is 1 iff the e^th element must be part of the final design\nwhite:  a BitVector of length equal to the number of elements where white[e] is 1 iff the e^th element must not be part of the final design\nvarind: an AbstractVector{Int} of length equal to the number of elements where varind[e] gives the index of the decision variable corresponding to element e. Because some elements can be fixed to be black or white, not every element has a decision variable associated.\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.TieBeam-Union{Tuple{Type{Val{CellType}}}, Tuple{CellType}, Tuple{T}, Tuple{Type{Val{CellType}},Type{T}}, Tuple{Type{Val{CellType}},Type{T},Any}, Tuple{Type{Val{CellType}},Type{T},Any,Any}} where CellType where T","page":"TopOptProblems","title":"TopOpt.TopOptProblems.TieBeam","text":"TieBeam(::Type{Val{CellType}}, ::Type{T} = Float64, refine = 1, force = T(1); E = T(1), ν = T(0.3)) where {T, CellType}\n\nT: number type for computations and coordinates\nE: Young's modulus\nν: Poisson's ration\nforce: force at the center right of the cantilever beam (positive is downward)\nrefine: an integer value of 1 or greater that specifies the mesh refinement extent. A value of 1 gives the standard tie-beam problem in literature.\nCellType: can be either :Linear or :Quadratic to determine the order of the geometric and field basis functions and element type. Only isoparametric elements are supported for now.\n\n\n\n\n\n","category":"method"},{"location":"reference/TopOptProblems/#Reading-INP-Files","page":"TopOptProblems","title":"Reading INP Files","text":"","category":"section"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"In TopOpt.jl, you can import a .inp file to an instance of the problem struct InpStiffness. This can be used to construct problems with arbitrary unstructured ground meshes, complex boundary condition domains and load specifications. The .inp file can be exported from a number of common finite element software such as: FreeCAD or ABAQUS.","category":"page"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"InpStiffness\nInpStiffness(filepath_with_ext::AbstractString; keep_load_cells = false)","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.IO.INP.InpStiffness","page":"TopOptProblems","title":"TopOpt.TopOptProblems.IO.INP.InpStiffness","text":"struct InpStiffness{dim, N, TF, TI, TBool, Tch <: ConstraintHandler, GO, TInds <: AbstractVector{TI}, TMeta<:Metadata} <: StiffnessTopOptProblem{dim, TF}\n    inp_content::InpContent{dim, TF, N, TI}\n    geom_order::Type{Val{GO}}\n    ch::Tch\n    black::TBool\n    white::TBool\n    varind::TInds\n    metadata::TMeta\nend\n\ndim: dimension of the problem\nTF: number type for computations and coordinates\nN: number of nodes in a cell of the grid\ninp_content: an instance of InpContent which stores all the information from the `.inp file.\ngeom_order: a field equal to Val{GO} where GO is an integer representing the order of the finite elements. Linear elements have a geom_order of Val{1} and quadratic elements have a geom_order of Val{2}.\nmetadata: Metadata having various cell-node-dof relationships\nblack: a BitVector of length equal to the number of elements where black[e] is 1 iff the e^th element must be part of the final design\nwhite:  a BitVector of length equal to the number of elements where white[e] is 1 iff the e^th element must not be part of the final design\nvarind: an AbstractVector{Int} of length equal to the number of elements where varind[e] gives the index of the decision variable corresponding to element e. Because some elements can be fixed to be black or white, not every element has a decision variable associated.\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.IO.INP.InpStiffness-Tuple{AbstractString}","page":"TopOptProblems","title":"TopOpt.TopOptProblems.IO.INP.InpStiffness","text":"InpStiffness(filepath::AbstractString; keep_load_cells = false)\n\nImports stiffness problem from a .inp file, e.g. InpStiffness(\"example.inp\"). The keep_load_cells keyword argument will enforce that any cell with a load applied on it is to be part of the final optimal design generated by topology optimization algorithms.\n\n\n\n\n\n","category":"method"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"IO.INP.Parser.InpContent","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.IO.INP.Parser.InpContent","page":"TopOptProblems","title":"TopOpt.TopOptProblems.IO.INP.Parser.InpContent","text":"struct InpContent{dim, TF, N, TI}\n    node_coords::Vector{NTuple{dim,TF}}\n    celltype::String\n    cells::Vector{NTuple{N,TI}}\n    nodesets::Dict{String,Vector{TI}}\n    cellsets::Dict{String,Vector{TI}}\n    E::TF\n    ν::TF\n    density::TF\n    nodedbcs::Dict{String, Vector{Tuple{TI,TF}}}\n    cloads::Dict{Int, Vector{TF}}\n    facesets::Dict{String, Vector{Tuple{TI,TI}}}\n    dloads::Dict{String, TF}\nend\n\nnode_coords: a vector of node coordinates.\ncelltype: a cell type code in the INP convention \ncells: a vector of cell connectivities\nnodesets: a dictionary mapping a node set name to a vector of node indices\ncellsets: a dictionary mapping a cell set name to a vector of cell indices\nE: Young's modulus\nν: Poisson ratio\ndensity: physical density of the material\nnodedbcs: a dictionary mapping a node set name to a vector of tuples of type Tuple{Int, Float64} specifying a Dirichlet boundary condition on that node set. Each tuple in the vector specifies the local index of a constrained degree of freedom and its fixed value. A 3-dimensional field has 3 degrees of freedom per node for example. So the index can be 1, 2 or 3.\ncloads: a dictionary mapping a node index to a load vector on that node.\nfacesets: a dictionary mapping a face set name to a vector of Tuple{Int,Int} tuples where each tuple is a face index. The first integer is the cell index where the face is and the second integer is the local face index in the cell according to the VTK convention.\ndloads: a dictionary of distributed loads mapping face set names to a normal traction load value.\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#Grids","page":"TopOptProblems","title":"Grids","text":"","category":"section"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"Grid types are defined in TopOptProblems because a number of topology optimization problems share the same underlying grid but apply the loads and boundary conditions at different locations. For example, the PointLoadCantilever and HalfMBB problems use the same rectilinear grid type, RectilinearGrid, under the hood. The LBeam problem uses the LGrid function under the hood to construct an L-shaped JuAFEM.Grid. New problem types can be defined using the same grids but different loads or boundary conditions.","category":"page"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"RectilinearGrid\nRectilinearGrid(::Type{Val{CellType}}, nels::NTuple{dim,Int}, sizes::NTuple{dim,T}) where {dim, T, CellType}","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.RectilinearGrid","page":"TopOptProblems","title":"TopOpt.TopOptProblems.RectilinearGrid","text":"struct RectilinearGrid{dim, T, N, M, TG<:JuAFEM.Grid{dim, <:JuAFEM.Cell{dim,N,M}, T}} <: AbstractGrid{dim, T}\n    grid::TG\n    nels::NTuple{dim, Int}\n    sizes::NTuple{dim, T}\n    corners::NTuple{2, Vec{dim, T}}\n    white_cells::BitVector\n    black_cells::BitVector\n    constant_cells::BitVector\nend\n\nA type that represents a rectilinear grid with corner points corners.\n\ndim: dimension of the problem\nT: number type for computations and coordinates\nN: number of nodes in a cell of the grid\nM: number of faces in a cell of the grid\ngrid: a JuAFEM.Grid struct\nnels: number of elements in every dimension\nsizes: dimensions of each rectilinear cell\ncorners: 2 corner points of the rectilinear grid\nwhite_cells: cells fixed to be void during optimization\nblack_cells: cells fixed to have material during optimization\nconstant_cells: cells fixed to be either void or have material during optimization\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.RectilinearGrid-Union{Tuple{CellType}, Tuple{T}, Tuple{dim}, Tuple{Type{Val{CellType}},Tuple{Vararg{Int64,dim}},Tuple{Vararg{T,dim}}}} where CellType where T where dim","page":"TopOptProblems","title":"TopOpt.TopOptProblems.RectilinearGrid","text":"RectilinearGrid(::Type{Val{CellType}}, nels::NTuple{dim,Int}, sizes::NTuple{dim,T}) where {dim, T, CellType}\n\nConstructs an instance of RectilinearGrid.\n\ndim: dimension of the problem\nT: number type for coordinates\nnels: number of elements in every dimension\nsizes: dimensions of each rectilinear cell\n\nExample:\n\nrectgrid = RectilinearGrid((60,20), (1.0,1.0))\n\n\n\n\n\n","category":"method"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"LGrid","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.LGrid","page":"TopOptProblems","title":"TopOpt.TopOptProblems.LGrid","text":"LGrid(::Type{Val{CellType}}, ::Type{T}; length = 100, height = 100, upperslab = 50, lowerslab = 50) where {T, CellType}\nLGrid(::Type{Val{CellType}}, nel1::NTuple{2,Int}, nel2::NTuple{2,Int}, LL::Vec{2,T}, UR::Vec{2,T}, MR::Vec{2,T}) where {CellType, T}\n\nConstructs a JuAFEM.Grid that represents the following L-shaped grid.\n\n        upperslab   UR\n       ............\n       .          .\n       .          .\n       .          . \nheight .          .                     MR\n       .          ......................\n       .                               .\n       .                               . lowerslab\n       .                               .\n       .................................\n     LL             length\n\n\n\nExamples:\n\nLGrid(upperslab = 30, lowerslab = 70)\nLGrid(Val{:Linear}, (2, 4), (2, 2), Vec{2,Float64}((0.0,0.0)), Vec{2,Float64}((2.0, 4.0)), Vec{2,Float64}((4.0, 2.0)))\n\n\n\n\n\n","category":"function"},{"location":"reference/TopOptProblems/#Finite-element-backend","page":"TopOptProblems","title":"Finite element backend","text":"","category":"section"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"Currently, TopOpt uses a forked version of JuAFEM.jl. This means that all the problems above are described in the language and types of JuAFEM.","category":"page"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"The fork is needed for GPU support but the main package should also work on the CPU. The changes in the fork should make it back to the main repo at some point.","category":"page"},{"location":"reference/TopOptProblems/#Matrices-and-vectors","page":"TopOptProblems","title":"Matrices and vectors","text":"","category":"section"},{"location":"reference/TopOptProblems/#ElementFEAInfo","page":"TopOptProblems","title":"ElementFEAInfo","text":"","category":"section"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"ElementFEAInfo\nElementFEAInfo(sp, quad_order, ::Type{Val{mat_type}}) where {mat_type}","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.ElementFEAInfo","page":"TopOptProblems","title":"TopOpt.TopOptProblems.ElementFEAInfo","text":"struct ElementFEAInfo{dim, T}\n    Kes::AbstractVector{<:AbstractMatrix{T}}\n    fes::AbstractVector{<:AbstractVector{T}}\n    fixedload::AbstractVector{T}\n    cellvolumes::AbstractVector{T}\n    cellvalues::CellValues{dim, T}\n    facevalues::FaceValues{<:Any, T}\n    metadata::Metadata\n    black::AbstractVector\n    white::AbstractVector\n    varind::AbstractVector{Int}\n    cells\nend\n\nAn instance of the ElementFEAInfo type stores element information such as:\n\nKes: the element stiffness matrices,\nfes: the element load vectors,\ncellvolumes: the element volumes,\ncellvalues and facevalues: two JuAFEM types that facilitate cell and face iteration and queries.\nmetadata: that stores degree of freedom (dof) to node mapping, dof to cell mapping, etc.\nblack: a BitVector such that black[i] is 1 iff element i must be part of any feasible design.\nwhite: a BitVector such that white[i] is 1 iff element i must never be part of any feasible design.\nvarind: a vector such that varind[i] gives the decision variable index of element i.\ncells: the cell connectivities.\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.ElementFEAInfo-Union{Tuple{mat_type}, Tuple{Any,Any,Type{Val{mat_type}}}} where mat_type","page":"TopOptProblems","title":"TopOpt.TopOptProblems.ElementFEAInfo","text":"ElementFEAInfo(sp, quad_order=2, ::Type{Val{mat_type}}=Val{:Static}) where {mat_type}\n\nConstructs an instance of ElementFEAInfo from a stiffness problem sp using a Gaussian quadrature order of quad_order. The element matrix and vector types will be:\n\nSMatrix and SVector if mat_type is :SMatrix or :Static, the default,\nMMatrix and MVector if mat_type is :MMatrix, or\nMatrix and Vector otherwise.\n\nThe static matrices and vectors are more performant and GPU-compatible therefore they are used by default.\n\n\n\n\n\n","category":"method"},{"location":"reference/TopOptProblems/#GlobalFEAInfo","page":"TopOptProblems","title":"GlobalFEAInfo","text":"","category":"section"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"GlobalFEAInfo\nGlobalFEAInfo(::Type{T}=Float64) where {T}\nGlobalFEAInfo(sp::StiffnessTopOptProblem)","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.GlobalFEAInfo","page":"TopOptProblems","title":"TopOpt.TopOptProblems.GlobalFEAInfo","text":"struct GlobalFEAInfo{T, TK<:AbstractMatrix{T}, Tf<:AbstractVector{T}, Tchol}\n    K::TK\n    f::Tf\n    cholK::Tchol\nend\n\nAn instance of GlobalFEAInfo hosts the global stiffness matrix K, the load vector f and the cholesky decomposition of the K, cholK.\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.GlobalFEAInfo-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"TopOptProblems","title":"TopOpt.TopOptProblems.GlobalFEAInfo","text":"GlobalFEAInfo(::Type{T}=Float64) where {T}\n\nConstructs an empty instance of GlobalFEAInfo where the field K is an empty sparse matrix of element type T and the field f is an empty dense vector of element type T.\n\n\n\n\n\n","category":"method"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.GlobalFEAInfo-Tuple{StiffnessTopOptProblem}","page":"TopOptProblems","title":"TopOpt.TopOptProblems.GlobalFEAInfo","text":"GlobalFEAInfo(sp::StiffnessTopOptProblem)\n\nConstructs an instance of GlobalFEAInfo where the field K is a sparse matrix with the correct size and sparsity pattern for the problem instance sp. The field f is a dense vector of the appropriate size. The values in K and f are meaningless though and require calling the function assemble! to update.\n\n\n\n\n\n","category":"method"},{"location":"examples/point_load_cantilever/","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"EditURL = \"https://github.com/mohamed82008/TopOpt.jl/blob/master/docs/src/literate/point_load_cantilever.jl\"","category":"page"},{"location":"examples/point_load_cantilever/#PointLoadCantilever","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"","category":"section"},{"location":"examples/point_load_cantilever/","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"tip: Tip\nThis example is also available as a Jupyter notebook: point_load_cantilever.ipynb","category":"page"},{"location":"examples/point_load_cantilever/#Commented-Program","page":"PointLoadCantilever","title":"Commented Program","text":"","category":"section"},{"location":"examples/point_load_cantilever/","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"Now we solve the problem in JuAFEM. What follows is a program spliced with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/point_load_cantilever/","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"using TopOpt, Makie\nimport GeometryBasics","category":"page"},{"location":"examples/point_load_cantilever/#Define-the-problem","page":"PointLoadCantilever","title":"Define the problem","text":"","category":"section"},{"location":"examples/point_load_cantilever/","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"E = 1.0 # Young’s modulus\nv = 0.3 # Poisson’s ratio\nf = 1.0; # downward force\n\nnels = (12, 6, 6) # change to (40, 20, 20) for a more high-res result\nproblem = PointLoadCantilever(Val{:Linear}, nels, (1.0, 1.0, 1.0), E, v, f);\nnothing #hide","category":"page"},{"location":"examples/point_load_cantilever/#Parameter-settings","page":"PointLoadCantilever","title":"Parameter settings","text":"","category":"section"},{"location":"examples/point_load_cantilever/","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"V = 0.3 # volume fraction\nxmin = 0.001 # minimum density\nrmin = 4.0; # density filter radius\nnothing #hide","category":"page"},{"location":"examples/point_load_cantilever/#Define-a-finite-element-solver","page":"PointLoadCantilever","title":"Define a finite element solver","text":"","category":"section"},{"location":"examples/point_load_cantilever/","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"penalty = TopOpt.PowerPenalty(3.0)\nsolver = FEASolver(Displacement, Direct, problem, xmin = xmin,\n    penalty = penalty);\nnothing #hide","category":"page"},{"location":"examples/point_load_cantilever/#Define-compliance-objective","page":"PointLoadCantilever","title":"Define compliance objective","text":"","category":"section"},{"location":"examples/point_load_cantilever/","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"obj = Objective(TopOpt.Compliance(problem, solver, filterT = DensityFilter,\n    rmin = rmin, tracing = true, logarithm = false));\nnothing #hide","category":"page"},{"location":"examples/point_load_cantilever/#Define-volume-constraint","page":"PointLoadCantilever","title":"Define volume constraint","text":"","category":"section"},{"location":"examples/point_load_cantilever/","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"constr = Constraint(TopOpt.Volume(problem, solver, filterT = DensityFilter, rmin = rmin), V);\nnothing #hide","category":"page"},{"location":"examples/point_load_cantilever/#Define-subproblem-optimizer","page":"PointLoadCantilever","title":"Define subproblem optimizer","text":"","category":"section"},{"location":"examples/point_load_cantilever/","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"mma_options = options = MMA.Options(maxiter = 3000,\n    tol = MMA.Tolerances(kkttol = 0.001))\nconvcriteria = MMA.KKTCriteria()\noptimizer = MMAOptimizer(obj, constr, MMA.MMA87(),\n    ConjugateGradient(), options = mma_options,\n    convcriteria = convcriteria);\nnothing #hide","category":"page"},{"location":"examples/point_load_cantilever/#Define-SIMP-optimizer","page":"PointLoadCantilever","title":"Define SIMP optimizer","text":"","category":"section"},{"location":"examples/point_load_cantilever/","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"simp = SIMP(optimizer, penalty.p);\nnothing #hide","category":"page"},{"location":"examples/point_load_cantilever/#Solve","page":"PointLoadCantilever","title":"Solve","text":"","category":"section"},{"location":"examples/point_load_cantilever/","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"x0 = fill(1.0, length(solver.vars))\nresult = simp(x0);\nnothing #hide","category":"page"},{"location":"examples/point_load_cantilever/#Visualize-the-result-using-Makie.jl","page":"PointLoadCantilever","title":"Visualize the result using Makie.jl","text":"","category":"section"},{"location":"examples/point_load_cantilever/","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"result_mesh = GeometryBasics.Mesh(problem, result.topology);\n\nmesh(result_mesh);\nnothing #hide","category":"page"},{"location":"examples/point_load_cantilever/#point-load-cantilever-plain-program","page":"PointLoadCantilever","title":"Plain Program","text":"","category":"section"},{"location":"examples/point_load_cantilever/","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"Below follows a version of the program without any comments. The file is also available here: pointloadcantilever.jl","category":"page"},{"location":"examples/point_load_cantilever/","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"using TopOpt, Makie\nimport GeometryBasics\n\nE = 1.0 # Young’s modulus\nv = 0.3 # Poisson’s ratio\nf = 1.0; # downward force\n\nnels = (12, 6, 6) # change to (40, 20, 20) for a more high-res result\nproblem = PointLoadCantilever(Val{:Linear}, nels, (1.0, 1.0, 1.0), E, v, f);\n\nV = 0.3 # volume fraction\nxmin = 0.001 # minimum density\nrmin = 4.0; # density filter radius\n\npenalty = TopOpt.PowerPenalty(3.0)\nsolver = FEASolver(Displacement, Direct, problem, xmin = xmin,\n    penalty = penalty);\n\nobj = Objective(TopOpt.Compliance(problem, solver, filterT = DensityFilter,\n    rmin = rmin, tracing = true, logarithm = false));\n\nconstr = Constraint(TopOpt.Volume(problem, solver, filterT = DensityFilter, rmin = rmin), V);\n\nmma_options = options = MMA.Options(maxiter = 3000,\n    tol = MMA.Tolerances(kkttol = 0.001))\nconvcriteria = MMA.KKTCriteria()\noptimizer = MMAOptimizer(obj, constr, MMA.MMA87(),\n    ConjugateGradient(), options = mma_options,\n    convcriteria = convcriteria);\n\nsimp = SIMP(optimizer, penalty.p);\n\nx0 = fill(1.0, length(solver.vars))\nresult = simp(x0);\n\nresult_mesh = GeometryBasics.Mesh(problem, result.topology);\n\nmesh(result_mesh);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/point_load_cantilever/","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"","category":"page"},{"location":"examples/point_load_cantilever/","page":"PointLoadCantilever","title":"PointLoadCantilever","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#TopOpt.jl-Documentation","page":"Home","title":"TopOpt.jl Documentation","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TopOpt is a topology optimization package written in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main functionalities of the package include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"...\n...","category":"page"},{"location":"","page":"Home","title":"Home","text":"The best way to get started with TopOpt is to look at the documented examples.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nTopOpt is still under development. If you find a bug, or have ideas for improvements, feel free to open an issue or make a pull request on the TopOpt GitHub page.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In Julia v1.0 you can install packages from the Pkg REPL (press ] in the Julia REPL to enter pkg> mode):","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/KristofferC/JuAFEM.jl.git\npkg> add https://github.com/mohamed82008/VTKDataTypes.jl#master\npkg> add https://github.com/mohamed82008/KissThreading.jl#master\npkg> add https://github.com/mohamed82008/TopOpt.jl#master","category":"page"},{"location":"","page":"Home","title":"Home","text":"To load the package, use","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TopOpt","category":"page"}]
}
