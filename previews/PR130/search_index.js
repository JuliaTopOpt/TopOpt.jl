var documenterSearchIndex = {"docs":
[{"location":"examples/global_stress/","page":"Global stress objective example","title":"Global stress objective example","text":"EditURL = \"https://github.com/JuliaTopOpt/TopOpt.jl/blob/master/docs/src/literate/global_stress.jl\"","category":"page"},{"location":"examples/global_stress/#Global-stress-objective-example","page":"Global stress objective example","title":"Global stress objective example","text":"","category":"section"},{"location":"examples/global_stress/","page":"Global stress objective example","title":"Global stress objective example","text":"tip: Tip\nThis example is also available as a Jupyter notebook: global_stress.ipynb","category":"page"},{"location":"examples/global_stress/#Commented-Program","page":"Global stress objective example","title":"Commented Program","text":"","category":"section"},{"location":"examples/global_stress/","page":"Global stress objective example","title":"Global stress objective example","text":"What follows is a program spliced with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/global_stress/","page":"Global stress objective example","title":"Global stress objective example","text":"using TopOpt, LinearAlgebra","category":"page"},{"location":"examples/global_stress/#Define-the-problem","page":"Global stress objective example","title":"Define the problem","text":"","category":"section"},{"location":"examples/global_stress/","page":"Global stress objective example","title":"Global stress objective example","text":"E = 1.0 # Young’s modulus\nv = 0.3 # Poisson’s ratio\nf = 1.0 # downward force\nrmin = 3.0 # filter radius\n\nproblems = Any[\n    PointLoadCantilever(Val{:Linear}, (60, 20), (1.0, 1.0), E, v, f),\n    HalfMBB(Val{:Linear}, (60, 20), (1.0, 1.0), E, v, f),\n]\nproblem_names = [\"Cantilever beam\", \"Half MBB beam\", \"L-beam\", \"Tie-beam\"]\n\ni = 1\nprintln(problem_names[i])\nproblem = problems[i]","category":"page"},{"location":"examples/global_stress/#Parameter-settings","page":"Global stress objective example","title":"Parameter settings","text":"","category":"section"},{"location":"examples/global_stress/","page":"Global stress objective example","title":"Global stress objective example","text":"V = 0.5 # volume fraction\nxmin = 0.001 # minimum density\nsteps = 40 # maximum number of penalty steps, delta_p0 = 0.1\nconvcriteria = Nonconvex.KKTCriteria()\npenalty = TopOpt.PowerPenalty(1.0)","category":"page"},{"location":"examples/global_stress/#Define-a-finite-element-solver","page":"Global stress objective example","title":"Define a finite element solver","text":"","category":"section"},{"location":"examples/global_stress/","page":"Global stress objective example","title":"Global stress objective example","text":"solver = FEASolver(Direct, problem; xmin=xmin, penalty=penalty)","category":"page"},{"location":"examples/global_stress/#Define-**stress**-objective","page":"Global stress objective example","title":"Define stress objective","text":"","category":"section"},{"location":"examples/global_stress/","page":"Global stress objective example","title":"Global stress objective example","text":"Notice that gradient is derived automatically by automatic differentiation (Zygote.jl)!","category":"page"},{"location":"examples/global_stress/","page":"Global stress objective example","title":"Global stress objective example","text":"stress = TopOpt.von_mises_stress_function(solver)\nfilter = if problem isa TopOptProblems.TieBeam\n    identity\nelse\n    DensityFilter(solver; rmin=rmin)\nend\nvolfrac = TopOpt.Volume(solver)\n\nx0 = ones(length(solver.vars))\nthreshold = 3 * maximum(stress(filter(PseudoDensities(x0))))\n\nobj = x -> volfrac(filter(PseudoDensities(x)))\nconstr = x -> norm(stress(filter(PseudoDensities(x))), 5) - threshold","category":"page"},{"location":"examples/global_stress/#Define-subproblem-optimizer","page":"Global stress objective example","title":"Define subproblem optimizer","text":"","category":"section"},{"location":"examples/global_stress/","page":"Global stress objective example","title":"Global stress objective example","text":"N = length(solver.vars)\nx0 = fill(0.5, N)\n\noptions = MMAOptions(; maxiter=2000, tol=Nonconvex.Tolerance(; kkt=1e-4), convcriteria)\nmodel = Model(obj)\naddvar!(model, zeros(N), ones(N))\nadd_ineq_constraint!(model, constr)\nalg = MMA87()\nr = optimize(model, alg, x0; options)\n\n@show obj(r.minimizer)\n@show constr(r.minimizer)","category":"page"},{"location":"examples/global_stress/#(Optional)-Visualize-the-result-using-Makie.jl","page":"Global stress objective example","title":"(Optional) Visualize the result using Makie.jl","text":"","category":"section"},{"location":"examples/global_stress/","page":"Global stress objective example","title":"Global stress objective example","text":"Need to run using Pkg; Pkg.add(Makie) first","category":"page"},{"location":"examples/global_stress/","page":"Global stress objective example","title":"Global stress objective example","text":"using TopOpt.TopOptProblems.Visualization: visualize\nfig = visualize(problem; topology = r.minimizer)\nMakie.display(fig)","category":"page"},{"location":"examples/global_stress/#global-stress-plain-program","page":"Global stress objective example","title":"Plain Program","text":"","category":"section"},{"location":"examples/global_stress/","page":"Global stress objective example","title":"Global stress objective example","text":"Below follows a version of the program without any comments. The file is also available here: global-stress.jl","category":"page"},{"location":"examples/global_stress/","page":"Global stress objective example","title":"Global stress objective example","text":"using TopOpt, LinearAlgebra\n\nE = 1.0 # Young’s modulus\nv = 0.3 # Poisson’s ratio\nf = 1.0 # downward force\nrmin = 3.0 # filter radius\n\nproblems = Any[\n    PointLoadCantilever(Val{:Linear}, (60, 20), (1.0, 1.0), E, v, f),\n    HalfMBB(Val{:Linear}, (60, 20), (1.0, 1.0), E, v, f),\n]\nproblem_names = [\"Cantilever beam\", \"Half MBB beam\", \"L-beam\", \"Tie-beam\"]\n\ni = 1\nprintln(problem_names[i])\nproblem = problems[i]\n\nV = 0.5 # volume fraction\nxmin = 0.001 # minimum density\nsteps = 40 # maximum number of penalty steps, delta_p0 = 0.1\nconvcriteria = Nonconvex.KKTCriteria()\npenalty = TopOpt.PowerPenalty(1.0)\n\nsolver = FEASolver(Direct, problem; xmin=xmin, penalty=penalty)\n\nstress = TopOpt.von_mises_stress_function(solver)\nfilter = if problem isa TopOptProblems.TieBeam\n    identity\nelse\n    DensityFilter(solver; rmin=rmin)\nend\nvolfrac = TopOpt.Volume(solver)\n\nx0 = ones(length(solver.vars))\nthreshold = 3 * maximum(stress(filter(PseudoDensities(x0))))\n\nobj = x -> volfrac(filter(PseudoDensities(x)))\nconstr = x -> norm(stress(filter(PseudoDensities(x))), 5) - threshold\n\nN = length(solver.vars)\nx0 = fill(0.5, N)\n\noptions = MMAOptions(; maxiter=2000, tol=Nonconvex.Tolerance(; kkt=1e-4), convcriteria)\nmodel = Model(obj)\naddvar!(model, zeros(N), ones(N))\nadd_ineq_constraint!(model, constr)\nalg = MMA87()\nr = optimize(model, alg, x0; options)\n\n@show obj(r.minimizer)\n@show constr(r.minimizer)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/global_stress/","page":"Global stress objective example","title":"Global stress objective example","text":"","category":"page"},{"location":"examples/global_stress/","page":"Global stress objective example","title":"Global stress objective example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"functions/#Differentiable-functions","page":"Functions","title":"Differentiable functions","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"All the following functions are defined in a differentiable way and you can use them in the objectives or constraints in topology optimization formulation. In TopOpt.jl, you can build arbitrarily complex objective and constraint functions using the following building blocks as lego pieces chaining them in any arbitrary way. The gradient and jacobian of the aggregate Julia function defined is then obtained using automatic differentiation. Beside the following specific functions, arbitrary differentiable Julia functions such as LinearAlgebra.norm and StatsFuns.logsumexp are also supported which can for example be used in aggregating constraints.","category":"page"},{"location":"functions/#Density-filter","page":"Functions","title":"Density filter","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Function name: DensityFilter\nDescription: Density chequerboard filter with a parameter rmin\nInput(s): Unfiltered design x::Vector{<:Real}\nOutput: Filtered design y::Vector{<:Real}\nConstructor example: flt = DensityFilter(solver, rmin = 3.0)\nUsage example: y = flt(x)","category":"page"},{"location":"functions/#Sensitivity-filter","page":"Functions","title":"Sensitivity filter","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Function name: SensFilter\nDescription: Sensitivity chequerboard filter with a parameter rmin\nInput(s): Unfiltered design x::Vector{<:Real}\nOutput: Filtered design y::Vector{<:Real}\nConstructor example: flt = SensFilter(solver, rmin = 3.0)\nUsage example: y = flt(x)","category":"page"},{"location":"functions/#Heaviside-projection","page":"Functions","title":"Heaviside projection","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Function name: HeavisideProjection\nDescription: Heaviside projection function with a parameter β for producing near binary designs\nInput(s): Filtered design x::Vector{<:Real}\nOutput: Projected design y::Vector{<:Real}\nConstructor example: proj = HeavisideProjection(5.0)\nUsage example: y = proj(x)","category":"page"},{"location":"functions/#Compliance","page":"Functions","title":"Compliance","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Function name: Compliance\nDescription: Compliance function which applies the penalty and interpolation, solves the finite element analysis and calculates the compliance\nInput(s): Filtered and optionally projected design x::Vector{<:Real}\nOutput: Compliance value comp::Real\nConstructor example: compf = Compliance(solver)\nUsage example: comp = compf(x)","category":"page"},{"location":"functions/#Volume","page":"Functions","title":"Volume","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Function name: Volume\nDescription: Volume or volume fraction function depending on the value of the parameter fraction (default is true)\nInput(s): Filtered and optionally projected design x::Vector{<:Real}\nOutput: Volume or volume fracton vol::Real\nConstructor example: compf = Compliance(solver)\nUsage example: comp = compf(x)","category":"page"},{"location":"functions/#Nodal-displacements","page":"Functions","title":"Nodal displacements","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Function name: Displacement\nDescription: Nodal displacements function which can be used to set a displacement constraint, minimize displacement or compute stresses and stress stiffness matrices\nInput(s): Filtered and optionally projected design x::Vector{<:Real}\nOutput: Displacements of all the nodes u::Vector{<:Real}\nConstructor example: disp = Displacement(solver)\nUsage example: u = disp(x)","category":"page"},{"location":"functions/#Element-wise-microscopic-stress-tensor","page":"Functions","title":"Element-wise microscopic stress tensor","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Function name: StressTensor\nDescription: A function computing the element-wise microscopic stress tensor which is useful in stress-constrained optimization and machine learning for topology optimization. The microscopic stress tensor uses the base Young's modulus to compute the stiffness tensor and calculate the stress tensor from the strain tensor.\nInput(s): Nodal displacements vector u::Vector{<:Real}. This could be computed by the Displacement function above.\nOutput: Element-wise microscopic stress tensor σ::Vector{<:Matrix{<:Real}}. This is a vector of symmetric matrices, one matrix for each element.\nConstructor example: σf = StressTensor(solver)\nUsage example: σ = σf(u)","category":"page"},{"location":"functions/#Element-wise-microscopic-von-Mises-stress","page":"Functions","title":"Element-wise microscopic von Mises stress","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Function name: von_mises_stress_function\nDescription: A function which applies the penalty and interpolation, solves the finite element analysis and computes the microscopic von Mises stress value for each element. The microscopic von Mises stress uses the base Young's modulus to compute the stiffness tensor and calculate the stress tensor from the strain tensor.\nInput(s): Filtered and optionally projected design x::Vector{<:Real\nOutput: Element-wise von Mises stress values σv::Vector{<:Real}\nConstructor example: σvf = von_mises_stress_function(solver)\nUsage example: σv = σvf(x)","category":"page"},{"location":"functions/#Element-stiffness-matrices","page":"Functions","title":"Element stiffness matrices","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Function name: ElementK\nDescription: A function which computes the element stiffness matrices from the input design variables. The function applies the penalty and interpolation on inputs followed by computing the element stiffness matrices using a quadrature approximation of the discretized integral. This function is useful in buckling-constrained optimization.\nInput(s): Filtered and optionally projected design x::Vector{<:Real}\nOutput: Element-wise stiffness matrices Kes::Vector{<:Matrix{<:Real}}. This is a vector of symmetric positive (semi-)definite matrices, one matrix for each element.\nConstructor example: Kesf = ElementK(solver)\nUsage example: Kes = Kesf(x)","category":"page"},{"location":"functions/#Matrix-assembly","page":"Functions","title":"Matrix assembly","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Function name: AssembleK\nDescription: A function which assembles the element-wise matrices to a global sparse matrix. This function is useful in buckling-constrained optimization.\nInput(s): Element-wise matrices Kes::Vector{<:Matrix{<:Real}}. This is a vector of symmetric matrices, one matrix for each element.\nOutput: Global assembled sparse matrix K::SparseMatrixCSC{<:Real}.\nConstructor example: assemble = AssembleK(problem)\nUsage example: K = assemble(Kes)","category":"page"},{"location":"functions/#Applying-Dirichlet-boundary-conditions-with-zeroing","page":"Functions","title":"Applying Dirichlet boundary conditions with zeroing","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Function name: apply_boundary_with_zerodiag!\nDescription: A function which zeroes out the columns and rows corresponding to degrees of freedom constrained by a Dirichlet boundary condition. This function is useful in buckling-constrained optimization.\nInput(s): Global assembled sparse matrix Kin::SparseMatrixCSC{<:Real} without boundary conditions applied.\nOutput: Global assembled sparse matrix Kout::SparseMatrixCSC{<:Real} with the boundary conditions applied.\nConstructor example: NA\nUsage example: Kout = apply_boundary_with_zerodiag!(Kin, problem.ch)","category":"page"},{"location":"functions/#Applying-Dirichlet-boundary-conditions-without-causing-singularity","page":"Functions","title":"Applying Dirichlet boundary conditions without causing singularity","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Function name: apply_boundary_with_meandiag!\nDescription: A function which zeroes out the columns and rows corresponding to degrees of freedom constrained by a Dirichlet boundary condition followed by calculating the mean diagonal and assigning it to the zeroed diagonal entries. This function applies the boundary conditions while maintaining the non-singularity of the output matrix.\nInput(s): Global assembled sparse matrix Kin::SparseMatrixCSC{<:Real} without boundary conditions applied.\nOutput: Global assembled sparse matrix Kout::SparseMatrixCSC{<:Real} with the boundary conditions applied.\nConstructor example: NA\nUsage example: Kout = apply_boundary_with_meandiag!(Kin, problem.ch)","category":"page"},{"location":"functions/#Macroscopic-truss-element-stress/geometric-stiffness-matrices","page":"Functions","title":"Macroscopic truss element stress/geometric stiffness matrices","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Function name: TrussElementKσ\nDescription: A function which computes the element-wise stress/geometric stiffness matrices for truss domains. This is useful in buckling-constrained truss optimization.\nInput(s): (1) The nodal displacement vector u::Vector{<:Real} computed from the Displacement function, and (2) the filtered, penalized, optionally projected and interpolated design ρ::Vector{<:Real}.\nOutput: The macroscopic element-wise stress/geometric stiffness matrices, Kσs::Vector{<:Matrix{<:Real}}. This is a vector of symmetric matrices, one matrix for each element.\nConstructor example: Kσsf = TrussElementKσ(problem, solver)\nUsage example: Kσs = Kσsf(u, ρ)","category":"page"},{"location":"functions/#Neural-network-re-parameterization","page":"Functions","title":"Neural network re-parameterization","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"Function name: NeuralNetwork\nDescription: A function which re-parameterizes the design in terms of a neural network's weights and biases. The input to the neural network model is the coordinates of the centroid of an element. The output is the design variable associated with this element (from 0 to 1). The model is called once for each element in \"prediction mode\". When using the model in training however, the inputs to the training function will be the parameters of the model (to be optimized) and the elements' centroids' coordinates will be conditioned upon. The output of the training function will be the vector of element-wise design variables which can be passed on to any of the above functions, e.g. Volume, DensityFilter, etc. In the constructor example below, nn can be an almost arbitrary Flux.jl neural network model, train_func is what needs to be used to define the objective or constraints in the re-parameterized topology optimization formulation and p0 is a vector of the neural network's initial weights and biases which can be used to initialize the optimization. The neural netowrk nn used must be one that can take 2 (or 3) input coordinates in the first layer for 2D (or 3D) problems and returns a scalar between 0 and 1 from the last layer. In prediction mode, this model will be called on each element using the centroid's coordinates as the input to neural network's first layer to compute the element's design variable. \nInput(s): train_func below takes the vector of neural network weights and biases, p::Vector{<:Real}, as input.\nOutput: train_func below returns the vector of element-wise design variables, x::Vector{<:Real}, as outputs.\nConstructor example:","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"nn_model = NeuralNetwork(nn, problem)   train_func = TrainFunction(nn_model)   p0 = nn_model.init_params","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Usage example: x = train_func(p)","category":"page"},{"location":"examples/TOBS/","page":"Topological optimization of binary structures (TOBS)","title":"Topological optimization of binary structures (TOBS)","text":"EditURL = \"https://github.com/JuliaTopOpt/TopOpt.jl/blob/master/docs/src/literate/TOBS.jl\"","category":"page"},{"location":"examples/TOBS/#Topological-optimization-of-binary-structures-(TOBS)","page":"Topological optimization of binary structures (TOBS)","title":"Topological optimization of binary structures (TOBS)","text":"","category":"section"},{"location":"examples/TOBS/#Description","page":"Topological optimization of binary structures (TOBS)","title":"Description","text":"","category":"section"},{"location":"examples/TOBS/","page":"Topological optimization of binary structures (TOBS)","title":"Topological optimization of binary structures (TOBS)","text":"The method of topological optimization of binary structures (TOBS) was originally developed in the context of optimal distribution of material in mechanical components. In its core, is a heuristic to solve binary optimization problems by first linearizing the objective and constraints. Then, a binary nonlinear program is solved (default solver is Cbc) to determine which binary variables must be flipped in the current iteration.","category":"page"},{"location":"examples/TOBS/#Packages-and-parameters","page":"Topological optimization of binary structures (TOBS)","title":"Packages and parameters","text":"","category":"section"},{"location":"examples/TOBS/","page":"Topological optimization of binary structures (TOBS)","title":"Topological optimization of binary structures (TOBS)","text":"using NonconvexTOBS, TopOpt\nE = 1.0 # Young’s modulus\nv = 0.3 # Poisson’s ratio\nf = 1.0 # downward force\nrmin = 6.0 # filter radius\nxmin = 0.001 # minimum density\nV = 0.5 # maximum volume fraction\np = 3.0 # topological optimization penalty","category":"page"},{"location":"examples/TOBS/#Define-FEA-problem","page":"Topological optimization of binary structures (TOBS)","title":"Define FEA problem","text":"","category":"section"},{"location":"examples/TOBS/","page":"Topological optimization of binary structures (TOBS)","title":"Topological optimization of binary structures (TOBS)","text":"problem_size = (160, 100); # size of rectangular mesh\nx0 = fill(1.0, prod(problem_size)); # initial design\nproblem = PointLoadCantilever(Val{:Linear}, problem_size, (1.0, 1.0), E, v, f);\nnothing #hide","category":"page"},{"location":"examples/TOBS/","page":"Topological optimization of binary structures (TOBS)","title":"Topological optimization of binary structures (TOBS)","text":"FEA solver and auxiliary functions need to be defined as well:","category":"page"},{"location":"examples/TOBS/","page":"Topological optimization of binary structures (TOBS)","title":"Topological optimization of binary structures (TOBS)","text":"solver = FEASolver(Direct, problem; xmin=xmin);\ncheqfilter = DensityFilter(solver; rmin=rmin); # filter function\ncomp = TopOpt.Compliance(solver); # compliance function\nnothing #hide","category":"page"},{"location":"examples/TOBS/","page":"Topological optimization of binary structures (TOBS)","title":"Topological optimization of binary structures (TOBS)","text":"The usual topology optimization problem adresses compliance minimization under volume restriction. Therefore, the objective and the constraint are:","category":"page"},{"location":"examples/TOBS/","page":"Topological optimization of binary structures (TOBS)","title":"Topological optimization of binary structures (TOBS)","text":"obj(x) = comp(cheqfilter(PseudoDensities(x))); # compliance objective\nconstr(x) = sum(cheqfilter(PseudoDensities(x))) / length(x) - V; # volume fraction constraint\nnothing #hide","category":"page"},{"location":"examples/TOBS/#Optimization-setup","page":"Topological optimization of binary structures (TOBS)","title":"Optimization setup","text":"","category":"section"},{"location":"examples/TOBS/","page":"Topological optimization of binary structures (TOBS)","title":"Topological optimization of binary structures (TOBS)","text":"Finally, the optimization problem is defined and solved:","category":"page"},{"location":"examples/TOBS/","page":"Topological optimization of binary structures (TOBS)","title":"Topological optimization of binary structures (TOBS)","text":"m = Model(obj); # create optimization model\naddvar!(m, zeros(length(x0)), ones(length(x0))); # setup optimization variables\nNonconvex.add_ineq_constraint!(m, constr); # setup volume inequality constraint\noptions = TOBSOptions(); # optimization options with default values\nTopOpt.setpenalty!(solver, p);\nnothing #hide","category":"page"},{"location":"examples/TOBS/","page":"Topological optimization of binary structures (TOBS)","title":"Topological optimization of binary structures (TOBS)","text":"Perform TOBS optimization","category":"page"},{"location":"examples/TOBS/","page":"Topological optimization of binary structures (TOBS)","title":"Topological optimization of binary structures (TOBS)","text":"@time r = Nonconvex.optimize(m, TOBSAlg(), x0; options=options)","category":"page"},{"location":"examples/TOBS/#Results","page":"Topological optimization of binary structures (TOBS)","title":"Results","text":"","category":"section"},{"location":"examples/TOBS/","page":"Topological optimization of binary structures (TOBS)","title":"Topological optimization of binary structures (TOBS)","text":"@show obj(r.minimizer)\n@show constr(r.minimizer)\ntopology = r.minimizer;\nnothing #hide","category":"page"},{"location":"examples/TOBS/","page":"Topological optimization of binary structures (TOBS)","title":"Topological optimization of binary structures (TOBS)","text":"","category":"page"},{"location":"examples/TOBS/","page":"Topological optimization of binary structures (TOBS)","title":"Topological optimization of binary structures (TOBS)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"EditURL = \"https://github.com/JuliaTopOpt/TopOpt.jl/blob/master/docs/src/literate/problem.jl\"","category":"page"},{"location":"examples/problem/#Problem-domain-definition","page":"Problem types","title":"Problem domain definition","text":"","category":"section"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"In this section, the syntax to construct multiple problem types will be shown. In TopOpt.jl, there are a number of standard topology optimization problem domains that can be defined using a few lines of code. This is for the convenience of testing and comparing algorithms and formulations on standard testing problems.","category":"page"},{"location":"examples/problem/#Continuum-problems","page":"Problem types","title":"Continuum problems","text":"","category":"section"},{"location":"examples/problem/#D-and-3D-point-load-cantilever-beam","page":"Problem types","title":"2D and 3D point load cantilever beam","text":"","category":"section"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"(Image: cantilever)","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"In this problem, the domain is divided into equally sized rectangular, quadrilateral elements. The number of elements (nels) and element sizes (elsizes) can be used to control the resolution of the problem's domain as well as its dimension. For instance, using nels = (160, 40) and elsizes = (1.0, 1.0) constructs a 2D problem domain of size 160 mm x 40 mm problem domain where each element is 1 mm x 1 mm. While nels = (160, 40, 40) and elsizes = (1.0, 1.0, 2.0) constructs a 3D problem domain of size 160 mm x 40 mm x 40 mm where each element is 1 mm x 1 mm x 2 mm.","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"Additionally, the Young’s modulus, Poisson’s ratio and downward force magnitude. Finally, the order of the geometric and field shape functions can be specified using either :Linear or :Quadratic as shown below.","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"using TopOpt\n\nE = 1.0 # Young’s modulus in MPa\nν = 0.3 # Poisson’s ratio\nf = 1.0 # downward force in N - negative is upward\nnels = (160, 40) # number of elements\nelsizes = (1.0, 1.0) # the size of each element in mm\norder = :Linear # shape function order\nproblem = PointLoadCantilever(Val{order}, nels, elsizes, E, ν, f)","category":"page"},{"location":"examples/problem/#D-and-3D-half-Messerschmitt–Bolkow–Blohm-(MBB)-beam-problem","page":"Problem types","title":"2D and 3D half Messerschmitt–Bolkow–Blohm (MBB) beam problem","text":"","category":"section"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"(Image: halfmbb)","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"A similar problem type exists for the well known half MBB problem shown above. The constructor and parameters are similar to that of the point load cantilever beam. Also 2D and 3D variants exist by changing the lengths of nels and elsizes.","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"E = 1.0 # Young’s modulus in MPa\nν = 0.3 # Poisson’s ratio\nf = 1.0 # downward force in N - negative is upward\nnels = (60, 20) # number of elements\nelsizes = (1.0, 1.0) # the size of each element in mm\norder = :Quadratic # shape function order\nproblem = HalfMBB(Val{order}, nels, elsizes, E, ν, f)","category":"page"},{"location":"examples/problem/#D-L-beam-problem","page":"Problem types","title":"2D L-beam problem","text":"","category":"section"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"(Image: lbeam)","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"The L-beam is another well known testing problem in topology optimization available in TopOpt.jl. To construct an L-beam problem, you can use the following constructor. The L-beam problem is only a 2D problem.","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"E = 1.0 # Young’s modulus in MPa\nν = 0.3 # Poisson’s ratio\nf = 1.0 # downward force in N - negative is upward\norder = :Quadratic # shape function order\nproblem = LBeam(\n    Val{order}; length=100, height=100, upperslab=50, lowerslab=50, E=1.0, ν=0.3, force=1.0\n)","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"where E, ν and force are the Young's modulus, Poisson's ratio and downward force respectively. The definition of length, height, upperslab and lowerslab are shown below. Each element is assumed to be a 1 mm x 1 mm element. The load is always applied at the midpoint of the \"lowerslab\" side. A positive value for the force is downward and a negative value is upward.","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"        upperslab\n       ............\n       .          .\n       .          .\n       .          .\nheight .          .\n       .          ......................\n       .                               .\n       .                               . lowerslab\n       .                               .\n       .................................\n                    length\n","category":"page"},{"location":"examples/problem/#D-tie-beam-problem","page":"Problem types","title":"2D tie-beam problem","text":"","category":"section"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"(Image: tiebeam)","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"The tie-beam problem shown above is a well-known problem in topology optimization literature. A distributed load of 1 N/mm is applied on the elements specified in the figure. To construct an instance of the tie-beam problem for a certain order of shape functions, you can use:","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"order = :Quadratic # shape function order\nproblem = TieBeam(Val{order})","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"The tie-beam problem only exists as a 2D problem.","category":"page"},{"location":"examples/problem/#Reading-INP-files","page":"Problem types","title":"Reading INP files","text":"","category":"section"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"Instead of defining a problem type programmatically, one can also use CAD/CAE software to define a 2D/3D problem domain using a graphical user interface and then export a .inp file from the CAD/CAE software. The .inp file can then be read into TopOpt.jl using:","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"filename = \"../data/problem.inp\" # path to inp file\nproblem = InpStiffness(filename);\nnothing #hide","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"For example, the following problem with fixed load, distributed loads and tetrahedral elements was defined usign FreeCAD and imported into TopOpt.jl to perform topology optimization.","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"(Image: inpfile)","category":"page"},{"location":"examples/problem/#Truss-problems","page":"Problem types","title":"Truss problems","text":"","category":"section"},{"location":"examples/problem/#D-and-3D-truss-problem-from-json-file","page":"Problem types","title":"2D and 3D truss problem from json file","text":"","category":"section"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"2D/3D truss problems can be imported from json files describing the nodes, elements, fixities and loading as shown below.","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"path_to_file = \"../data/tim_2d.json\" # path to json file\nmats = TrussFEAMaterial(10.0, 0.3) # Young’s modulus and Poisson’s ratio\ncrossecs = TrussFEACrossSec(800.0) # Cross-sectional area\nnode_points, elements, _, _, fixities, load_cases = load_truss_json(path_to_file)\nloads = load_cases[\"0\"]\nproblem = TrussProblem(Val{:Linear}, node_points, elements, loads, fixities, mats, crossecs);\nnothing #hide","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"The structure of the JSON file can be displayed using the code below, where f is a Julia dictionary.","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"using JSON\n\nf = JSON.parsefile(path_to_file)\nprint(JSON.json(f, 2));\nnothing #hide","category":"page"},{"location":"examples/problem/#D-and-3D-truss-point-load-cantilever-beam","page":"Problem types","title":"2D and 3D truss point load cantilever beam","text":"","category":"section"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"(Image: truss_cantilever)","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"Much like the continuum 2D/3D point load cantilever beam, you can also create a 2D/3D truss-based cantilever beam with a point load as shown above using the following syntax.","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"E = 1.0 # Young’s modulus in MPa\nν = 0.3 # Poisson’s ratio\nnels = (60, 20) # number of boundary trusses\nelsizes = (1.0, 1.0) # the length of each boundary truss in mm\nforce = 1.0 # upward force in N - negative is downward\nproblem = PointLoadCantileverTruss(nels, elsizes, E, ν, force; k_connect=1);\nnothing #hide","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"nels, elsizes, E and ν have an analagous intepretation to the continuum cantilever beam. force is the upward concentrated force in Newton (downward is negative). k_connect is the k-ring of each node defining the connectivity of the nodes in the graph, default is 1. For a 2D domain, a node will be connected to 8 neighboring nodes if k_connect = 1, and 8 + 16 = 24 neighboring nodes if k_connect = 2.","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"","category":"page"},{"location":"examples/problem/","page":"Problem types","title":"Problem types","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/beso/","page":"BESO example: HalfMBB Beam","title":"BESO example: HalfMBB Beam","text":"EditURL = \"https://github.com/JuliaTopOpt/TopOpt.jl/blob/master/docs/src/literate/beso.jl\"","category":"page"},{"location":"examples/beso/#BESO-example:-HalfMBB-Beam","page":"BESO example: HalfMBB Beam","title":"BESO example: HalfMBB Beam","text":"","category":"section"},{"location":"examples/beso/","page":"BESO example: HalfMBB Beam","title":"BESO example: HalfMBB Beam","text":"tip: Tip\nThis example is also available as a Jupyter notebook: beso.ipynb","category":"page"},{"location":"examples/beso/#Commented-Program","page":"BESO example: HalfMBB Beam","title":"Commented Program","text":"","category":"section"},{"location":"examples/beso/","page":"BESO example: HalfMBB Beam","title":"BESO example: HalfMBB Beam","text":"What follows is a program spliced with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/beso/","page":"BESO example: HalfMBB Beam","title":"BESO example: HalfMBB Beam","text":"using TopOpt","category":"page"},{"location":"examples/beso/#Define-the-problem","page":"BESO example: HalfMBB Beam","title":"Define the problem","text":"","category":"section"},{"location":"examples/beso/","page":"BESO example: HalfMBB Beam","title":"BESO example: HalfMBB Beam","text":"E = 1.0 # Young’s modulus\nv = 0.3 # Poisson’s ratio\nf = 1.0; # downward force\n\nnels = (160, 40)\nproblem = HalfMBB(Val{:Linear}, nels, (1.0, 1.0), E, v, f)","category":"page"},{"location":"examples/beso/#Define-the-FEA-Solver-and-penalty-functions","page":"BESO example: HalfMBB Beam","title":"Define the FEA Solver and penalty functions","text":"","category":"section"},{"location":"examples/beso/","page":"BESO example: HalfMBB Beam","title":"BESO example: HalfMBB Beam","text":"solver = FEASolver(Direct, problem; xmin=0.01, penalty=TopOpt.PowerPenalty(3.0))","category":"page"},{"location":"examples/beso/#Define-the-compliance-objective-function-and-volume-fraction-constraint","page":"BESO example: HalfMBB Beam","title":"Define the compliance objective function and volume fraction constraint","text":"","category":"section"},{"location":"examples/beso/","page":"BESO example: HalfMBB Beam","title":"BESO example: HalfMBB Beam","text":"comp = Compliance(solver)\nvolfrac = Volume(solver)\nsensfilter = SensFilter(solver; rmin=4.0)\nbeso = BESO(comp, volfrac, 0.5, sensfilter)","category":"page"},{"location":"examples/beso/#Run-optimization","page":"BESO example: HalfMBB Beam","title":"Run optimization","text":"","category":"section"},{"location":"examples/beso/","page":"BESO example: HalfMBB Beam","title":"BESO example: HalfMBB Beam","text":"x0 = ones(length(solver.vars))\nresult = beso(x0)","category":"page"},{"location":"examples/beso/#(Optional)-Visualize-the-result-using-Makie.jl","page":"BESO example: HalfMBB Beam","title":"(Optional) Visualize the result using Makie.jl","text":"","category":"section"},{"location":"examples/beso/","page":"BESO example: HalfMBB Beam","title":"BESO example: HalfMBB Beam","text":"Need to run using Pkg; Pkg.add(Makie) first","category":"page"},{"location":"examples/beso/","page":"BESO example: HalfMBB Beam","title":"BESO example: HalfMBB Beam","text":"using TopOpt.TopOptProblems.Visualization: visualize\nfig = visualize(problem; topology = result.topology)\nMakie.display(fig)","category":"page"},{"location":"examples/beso/#beso-plain-program","page":"BESO example: HalfMBB Beam","title":"Plain Program","text":"","category":"section"},{"location":"examples/beso/","page":"BESO example: HalfMBB Beam","title":"BESO example: HalfMBB Beam","text":"Below follows a version of the program without any comments. The file is also available here: beso.jl","category":"page"},{"location":"examples/beso/","page":"BESO example: HalfMBB Beam","title":"BESO example: HalfMBB Beam","text":"using TopOpt\n\nE = 1.0 # Young’s modulus\nv = 0.3 # Poisson’s ratio\nf = 1.0; # downward force\n\nnels = (160, 40)\nproblem = HalfMBB(Val{:Linear}, nels, (1.0, 1.0), E, v, f)\n\nsolver = FEASolver(Direct, problem; xmin=0.01, penalty=TopOpt.PowerPenalty(3.0))\n\ncomp = Compliance(solver)\nvolfrac = Volume(solver)\nsensfilter = SensFilter(solver; rmin=4.0)\nbeso = BESO(comp, volfrac, 0.5, sensfilter)\n\nx0 = ones(length(solver.vars))\nresult = beso(x0)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/beso/","page":"BESO example: HalfMBB Beam","title":"BESO example: HalfMBB Beam","text":"","category":"page"},{"location":"examples/beso/","page":"BESO example: HalfMBB Beam","title":"BESO example: HalfMBB Beam","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/local_stress/","page":"-","title":"-","text":"EditURL = \"https://github.com/JuliaTopOpt/TopOpt.jl/blob/master/docs/src/literate/local_stress.jl\"","category":"page"},{"location":"examples/local_stress/","page":"-","title":"-","text":"using Revise","category":"page"},{"location":"examples/local_stress/","page":"-","title":"-","text":"using TopOpt, LinearAlgebra, StatsFuns\nusing StatsFuns: logsumexp\n\nE = 1.0 # Young’s modulus\nv = 0.3 # Poisson’s ratio\nf = 1.0 # downward force\nrmin = 3.0","category":"page"},{"location":"examples/local_stress/#Define-the-problem","page":"-","title":"Define the problem","text":"","category":"section"},{"location":"examples/local_stress/","page":"-","title":"-","text":"problem = PointLoadCantilever(Val{:Linear}, (160, 40), (1.0, 1.0), E, v, f)","category":"page"},{"location":"examples/local_stress/#Parameter-settings","page":"-","title":"Parameter settings","text":"","category":"section"},{"location":"examples/local_stress/","page":"-","title":"-","text":"V = 0.5 # volume fraction\nxmin = 0.0001 # minimum density\nsteps = 40 # maximum number of penalty steps, delta_p0 = 0.1","category":"page"},{"location":"examples/local_stress/#Continuation-SIMP","page":"-","title":"Continuation SIMP","text":"","category":"section"},{"location":"examples/local_stress/","page":"-","title":"-","text":"x0 = fill(0.5, 160 * 40) # initial design\nN = length(x0)\npenalty = TopOpt.PowerPenalty(1.0)\nsolver = FEASolver(Direct, problem; xmin=xmin, penalty=penalty)\nstress = TopOpt.von_mises_stress_function(solver)\nfilter = DensityFilter(solver; rmin=rmin)\nvolfrac = TopOpt.Volume(solver)\n\nobj = x -> volfrac(filter(PseudoDensities(x))) - V\nthr = 150 # stress threshold\nconstr = x -> begin\n    s = stress(filter(PseudoDensities(x)))\n    return (s .- thr) / length(s)\nend\nalg = PercivalAlg()\noptions = PercivalOptions()\nmodel = Model(obj)\naddvar!(model, zeros(N), ones(N))\nadd_ineq_constraint!(model, constr)\n\nx = copy(x0)\nfor p in [1.0, 2.0, 3.0]\n    TopOpt.setpenalty!(solver, p)\n    global r = optimize(model, alg, x; options)\n    global x = r.minimizer\nend\n\nmaximum(stress(filter(PseudoDensities(x0))))\nmaximum(stress(filter(PseudoDensities(x))))","category":"page"},{"location":"examples/local_stress/#(Optional)-Visualize-the-result-using-Makie.jl","page":"-","title":"(Optional) Visualize the result using Makie.jl","text":"","category":"section"},{"location":"examples/local_stress/","page":"-","title":"-","text":"Need to run using Pkg; Pkg.add(Makie) first","category":"page"},{"location":"examples/local_stress/","page":"-","title":"-","text":"using Makie\nusing TopOpt.TopOptProblems.Visualization: visualize\nfig = visualize(\n   problem; topology = r.minimizer, default_exagg_scale = 0.07,\n   scale_range = 10.0, vector_linewidth = 3, vector_arrowsize = 0.5,\n)\nMakie.display(fig)","category":"page"},{"location":"examples/local_stress/#local-stress-plain-program","page":"-","title":"Plain Program","text":"","category":"section"},{"location":"examples/local_stress/","page":"-","title":"-","text":"Below follows a version of the program without any comments. The file is also available here: local-stress.jl","category":"page"},{"location":"examples/local_stress/","page":"-","title":"-","text":"using TopOpt, LinearAlgebra, StatsFuns\nusing StatsFuns: logsumexp\n\nE = 1.0 # Young’s modulus\nv = 0.3 # Poisson’s ratio\nf = 1.0 # downward force\nrmin = 3.0\n\nproblem = PointLoadCantilever(Val{:Linear}, (160, 40), (1.0, 1.0), E, v, f)\n\nV = 0.5 # volume fraction\nxmin = 0.0001 # minimum density\nsteps = 40 # maximum number of penalty steps, delta_p0 = 0.1\n\nx0 = fill(0.5, 160 * 40) # initial design\nN = length(x0)\npenalty = TopOpt.PowerPenalty(1.0)\nsolver = FEASolver(Direct, problem; xmin=xmin, penalty=penalty)\nstress = TopOpt.von_mises_stress_function(solver)\nfilter = DensityFilter(solver; rmin=rmin)\nvolfrac = TopOpt.Volume(solver)\n\nobj = x -> volfrac(filter(PseudoDensities(x))) - V\nthr = 150 # stress threshold\nconstr = x -> begin\n    s = stress(filter(PseudoDensities(x)))\n    return (s .- thr) / length(s)\nend\nalg = PercivalAlg()\noptions = PercivalOptions()\nmodel = Model(obj)\naddvar!(model, zeros(N), ones(N))\nadd_ineq_constraint!(model, constr)\n\nx = copy(x0)\nfor p in [1.0, 2.0, 3.0]\n    TopOpt.setpenalty!(solver, p)\n    global r = optimize(model, alg, x; options)\n    global x = r.minimizer\nend\n\nmaximum(stress(filter(PseudoDensities(x0))))\nmaximum(stress(filter(PseudoDensities(x))))\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/local_stress/","page":"-","title":"-","text":"","category":"page"},{"location":"examples/local_stress/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/Algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"reference/Algorithms/","page":"Algorithms","title":"Algorithms","text":"This sub-module of TopOpt defines a number of standard topology optimization algorithms.","category":"page"},{"location":"reference/Algorithms/","page":"Algorithms","title":"Algorithms","text":"CurrentModule = TopOpt.Algorithms","category":"page"},{"location":"reference/Algorithms/#Outer-Optimizer","page":"Algorithms","title":"Outer Optimizer","text":"","category":"section"},{"location":"reference/Algorithms/#Abstract-type","page":"Algorithms","title":"Abstract type","text":"","category":"section"},{"location":"reference/Algorithms/","page":"Algorithms","title":"Algorithms","text":"TODO.","category":"page"},{"location":"reference/Algorithms/#SIMP","page":"Algorithms","title":"SIMP","text":"","category":"section"},{"location":"reference/Algorithms/#Continuation-CSIMP","page":"Algorithms","title":"Continuation CSIMP","text":"","category":"section"},{"location":"reference/Algorithms/#BESO","page":"Algorithms","title":"BESO","text":"","category":"section"},{"location":"reference/Algorithms/","page":"Algorithms","title":"Algorithms","text":"BESO","category":"page"},{"location":"reference/Algorithms/#TopOpt.Algorithms.BESO","page":"Algorithms","title":"TopOpt.Algorithms.BESO","text":"The BESO algorithm, see Xiaodong Huang, Yi-Min Xie (2010).\n\n\n\n\n\n","category":"type"},{"location":"reference/Algorithms/#GESO","page":"Algorithms","title":"GESO","text":"","category":"section"},{"location":"reference/Algorithms/","page":"Algorithms","title":"Algorithms","text":"GESO","category":"page"},{"location":"reference/Algorithms/#TopOpt.Algorithms.GESO","page":"Algorithms","title":"TopOpt.Algorithms.GESO","text":"The GESO algorithm, see Xia Liu, Wei-Jian Yi, Q. S. Li, Pu-Sheng Shen (2008).\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#TopOptProblems","page":"TopOptProblems","title":"TopOptProblems","text":"","category":"section"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"This sub-module of TopOpt defines a number of standard topology optimization problems for the convenient testing of algorithms.","category":"page"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"CurrentModule = TopOpt.TopOptProblems","category":"page"},{"location":"reference/TopOptProblems/#Problem-types","page":"TopOptProblems","title":"Problem types","text":"","category":"section"},{"location":"reference/TopOptProblems/#Abstract-type","page":"TopOptProblems","title":"Abstract type","text":"","category":"section"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"StiffnessTopOptProblem is an abstract type that a number of linear elasticity, quasi-static, topology optimization problems subtype.","category":"page"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"StiffnessTopOptProblem","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.StiffnessTopOptProblem","page":"TopOptProblems","title":"TopOpt.TopOptProblems.StiffnessTopOptProblem","text":"abstract type StiffnessTopOptProblem{dim, T} <: AbstractTopOptProblem end\n\nAn abstract stiffness topology optimization problem. All subtypes must have the following fields:\n\nch: a Ferrite.ConstraintHandler struct\nmetadata: Metadata having various cell-node-dof relationships\nblack: a BitVector of length equal to the number of elements where black[e] is 1 iff the e^th element must be part of the final design\nwhite:  a BitVector of length equal to the number of elements where white[e] is 1 iff the e^th element must not be part of the final design\nvarind: an AbstractVector{Int} of length equal to the number of elements where varind[e] gives the index of the decision variable corresponding to element e. Because some elements can be fixed to be black or white, not every element has a decision variable associated.\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#Test-problems","page":"TopOptProblems","title":"Test problems","text":"","category":"section"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"The following types are all concrete subtypes of StiffnessTopOptProblem. PointLoadCantilever is a cantilever beam problem with a point load as shown below. HalfMBB is the half Messerschmitt-Bölkow-Blohm (MBB) beam problem commonly used in topology optimization literature. LBeam and TieBeam are the common L-beam and tie-beam test problem used in topology optimization literature. The PointLoadCantilever and HalfMBB problems can be either 2D or 3D depending on the type of the inputs to the constructor. If the number of elements and sizes of elements are 2-tuples, the problem constructed will be 2D. And if they are 3-tuples, the problem constructed will be 3D. For the 3D versions, the point loads are applied at approximately the mid-depth point. The TieBeam and LBeam problems are always 2D.","category":"page"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"PointLoadCantilever\nPointLoadCantilever(::Type{Val{CellType}}, nels::NTuple{dim,Int}, sizes::NTuple{dim}, E, ν, force) where {dim, CellType}","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.PointLoadCantilever-Union{Tuple{CellType}, Tuple{dim}, Tuple{Type{Val{CellType}}, Tuple{Vararg{Int64, dim}}, Tuple{Vararg{T, dim}} where T, Any, Any, Any}} where {dim, CellType}","page":"TopOptProblems","title":"TopOpt.TopOptProblems.PointLoadCantilever","text":"PointLoadCantilever(::Type{Val{CellType}}, nels::NTuple{dim,Int}, sizes::NTuple{dim}, E, ν, force) where {dim, CellType}\n\ndim: dimension of the problem\nE: Young's modulus\nν: Poisson's ration\nforce: force at the center right of the cantilever beam (positive is downward)\nnels: number of elements in each direction, a 2-tuple for 2D problems and a 3-tuple for 3D problems\nsizes: the size of each element in each direction, a 2-tuple for 2D problems and a 3-tuple for 3D problems\nCellType: can be either :Linear or :Quadratic to determine the order of the geometric and field basis functions and element type. Only isoparametric elements are supported for now.\n\nExample:\n\nnels = (60,20);\nsizes = (1.0,1.0);\nE = 1.0;\nν = 0.3;\nforce = 1.0;\n\n# Linear elements and linear basis functions\ncelltype = :Linear\n\n# Quadratic elements and quadratic basis functions\n#celltype = :Quadratic\n\nproblem = PointLoadCantilever(Val{celltype}, nels, sizes, E, ν, force)\n\n\n\n\n\n","category":"method"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"HalfMBB\nHalfMBB(::Type{Val{CellType}}, nels::NTuple{dim,Int}, sizes::NTuple{dim}, E, ν, force) where {dim, CellType}","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.HalfMBB","page":"TopOptProblems","title":"TopOpt.TopOptProblems.HalfMBB","text":" |\n |\n v\nO*********************************\nO*                               *\nO*                               *\nO*                               *\nO*********************************\n                                 O\n\nstruct HalfMBB{dim, T, N, M} <: StiffnessTopOptProblem{dim, T}\n    rect_grid::RectilinearGrid{dim, T, N, M}\n    E::T\n    ν::T\n    ch::ConstraintHandler{<:DofHandler{dim, <:Cell{dim,N,M}, T}, T}\n    force::T\n    force_dof::Integer\n    black::AbstractVector\n    white::AbstractVector\n    varind::AbstractVector{Int}\n    metadata::Metadata\nend\n\ndim: dimension of the problem\nT: number type for computations and coordinates\nN: number of nodes in a cell of the grid\nM: number of faces in a cell of the grid\nrect_grid: a RectilinearGrid struct\nE: Young's modulus\nν: Poisson's ration\nforce: force at the top left of half the MBB (positive is downward)\nforce_dof: dof number at which the force is applied\nch: a Ferrite.ConstraintHandler struct\nmetadata: Metadata having various cell-node-dof relationships\nblack: a BitVector of length equal to the number of elements where black[e] is 1 iff the e^th element must be part of the final design\nwhite:  a BitVector of length equal to the number of elements where white[e] is 1 iff the e^th element must not be part of the final design\nvarind: an AbstractVector{Int} of length equal to the number of elements where varind[e] gives the index of the decision variable corresponding to element e. Because some elements can be fixed to be black or white, not every element has a decision variable associated.\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.HalfMBB-Union{Tuple{CellType}, Tuple{dim}, Tuple{Type{Val{CellType}}, Tuple{Vararg{Int64, dim}}, Tuple{Vararg{T, dim}} where T, Any, Any, Any}} where {dim, CellType}","page":"TopOptProblems","title":"TopOpt.TopOptProblems.HalfMBB","text":"HalfMBB(::Type{Val{CellType}}, nels::NTuple{dim,Int}, sizes::NTuple{dim}, E, ν, force) where {dim, CellType}\n\ndim: dimension of the problem\nE: Young's modulus\nν: Poisson's ration\nforce: force at the top left of half the MBB (positive is downward)\nnels: number of elements in each direction, a 2-tuple for 2D problems and a 3-tuple for 3D problems\nsizes: the size of each element in each direction, a 2-tuple for 2D problems and a 3-tuple for 3D problems\nCellType: can be either :Linear or :Quadratic to determine the order of the geometric and field basis functions and element type. Only isoparametric elements are supported for now.\n\nExample:\n\nnels = (60,20);\nsizes = (1.0,1.0);\nE = 1.0;\nν = 0.3;\nforce = -1.0;\n\n# Linear elements and linear basis functions\ncelltype = :Linear\n\n# Quadratic elements and quadratic basis functions\n#celltype = :Quadratic\n\nproblem = HalfMBB(Val{celltype}, nels, sizes, E, ν, force)\n\n\n\n\n\n","category":"method"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"LBeam\nLBeam(::Type{Val{CellType}}, ::Type{T}=Float64; length = 100, height = 100, upperslab = 50, lowerslab = 50, E = 1.0, ν = 0.3, force = 1.0) where {T, CellType}","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.LBeam","page":"TopOptProblems","title":"TopOpt.TopOptProblems.LBeam","text":"////////////\n............\n.          .\n.          .\n.          . \n.          .                    \n.          ......................\n.                               .\n.                               . \n.                               . |\n................................. v\n                                force\n\nstruct LBeam{T, N, M} <: StiffnessTopOptProblem{2, T}\n    E::T\n    ν::T\n    ch::ConstraintHandler{<:DofHandler{2, <:Cell{2,N,M}, T}, T}\n    force::T\n    force_dof::Integer\n    black::AbstractVector\n    white::AbstractVector\n    varind::AbstractVector{Int}\n    metadata::Metadata\nend\n\nT: number type for computations and coordinates\nN: number of nodes in a cell of the grid\nM: number of faces in a cell of the grid\nE: Young's modulus\nν: Poisson's ration\nforce: force at the center right of the cantilever beam (positive is downward)\nforce_dof: dof number at which the force is applied\nch: a Ferrite.ConstraintHandler struct\nmetadata: Metadata having various cell-node-dof relationships\nblack: a BitVector of length equal to the number of elements where black[e] is 1 iff the e^th element must be part of the final design\nwhite:  a BitVector of length equal to the number of elements where white[e] is 1 iff the e^th element must not be part of the final design\nvarind: an AbstractVector{Int} of length equal to the number of elements where varind[e] gives the index of the decision variable corresponding to element e. Because some elements can be fixed to be black or white, not every element has a decision variable associated.\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.LBeam-Union{Tuple{Type{Val{CellType}}}, Tuple{CellType}, Tuple{T}, Tuple{Type{Val{CellType}}, Type{T}}} where {T, CellType}","page":"TopOptProblems","title":"TopOpt.TopOptProblems.LBeam","text":"LBeam(::Type{Val{CellType}}, ::Type{T}=Float64; length = 100, height = 100, upperslab = 50, lowerslab = 50, E = 1.0, ν = 0.3, force = 1.0) where {T, CellType}\n\nT: number type for computations and coordinates\nE: Young's modulus\nν: Poisson's ration\nforce: force at the center right of the cantilever beam (positive is downward)\nlength, height, upperslab and lowerslab are explained in LGrid.\nCellType: can be either :Linear or :Quadratic to determine the order of the geometric and field basis functions and element type. Only isoparametric elements are supported for now.\n\nExample:\n\nE = 1.0;\nν = 0.3;\nforce = 1.0;\n\n# Linear elements and linear basis functions\ncelltype = :Linear\n\n# Quadratic elements and quadratic basis functions\n#celltype = :Quadratic\n\nproblem = LBeam(Val{celltype}, E = E, ν = ν, force = force)\n\n\n\n\n\n","category":"method"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"TieBeam\nTieBeam(::Type{Val{CellType}}, ::Type{T} = Float64, refine = 1, force = T(1); E = T(1), ν = T(0.3)) where {T, CellType}","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.TieBeam","page":"TopOptProblems","title":"TopOpt.TopOptProblems.TieBeam","text":"                                                               1\n                                                               \n                                                              OOO\n                                                              ...\n                                                              . .\n                                                           4  . . \n                                30                            . .   \n/ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <-\n/ .                                                                 . <- 2 f \n/ .    3                                                            . <- \n/ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . <-\n                                                              ^^^\n                                                              |||\n                                                              1 f\n\nstruct TieBeam{T, N, M} <: StiffnessTopOptProblem{2, T}\n    E::T\n    ν::T\n    force::T\n    ch::ConstraintHandler{<:DofHandler{2, N, T, M}, T}\n    black::AbstractVector\n    white::AbstractVector\n    varind::AbstractVector{Int}\n    metadata::Metadata\nend\n\nT: number type for computations and coordinates\nN: number of nodes in a cell of the grid\nM: number of faces in a cell of the grid\nE: Young's modulus\nν: Poisson's ration\nforce: force at the center right of the cantilever beam (positive is downward)\nch: a Ferrite.ConstraintHandler struct\nmetadata: Metadata having various cell-node-dof relationships\nblack: a BitVector of length equal to the number of elements where black[e] is 1 iff the e^th element must be part of the final design\nwhite:  a BitVector of length equal to the number of elements where white[e] is 1 iff the e^th element must not be part of the final design\nvarind: an AbstractVector{Int} of length equal to the number of elements where varind[e] gives the index of the decision variable corresponding to element e. Because some elements can be fixed to be black or white, not every element has a decision variable associated.\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.TieBeam-Union{Tuple{Type{Val{CellType}}}, Tuple{CellType}, Tuple{T}, Tuple{Type{Val{CellType}}, Type{T}}, Tuple{Type{Val{CellType}}, Type{T}, Any}, Tuple{Type{Val{CellType}}, Type{T}, Any, Any}} where {T, CellType}","page":"TopOptProblems","title":"TopOpt.TopOptProblems.TieBeam","text":"TieBeam(::Type{Val{CellType}}, ::Type{T} = Float64, refine = 1, force = T(1); E = T(1), ν = T(0.3)) where {T, CellType}\n\nT: number type for computations and coordinates\nE: Young's modulus\nν: Poisson's ration\nforce: force at the center right of the cantilever beam (positive is downward)\nrefine: an integer value of 1 or greater that specifies the mesh refinement extent. A value of 1 gives the standard tie-beam problem in literature.\nCellType: can be either :Linear or :Quadratic to determine the order of the geometric and field basis functions and element type. Only isoparametric elements are supported for now.\n\n\n\n\n\n","category":"method"},{"location":"reference/TopOptProblems/#Reading-INP-Files","page":"TopOptProblems","title":"Reading INP Files","text":"","category":"section"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"In TopOpt.jl, you can import a .inp file to an instance of the problem struct InpStiffness. This can be used to construct problems with arbitrary unstructured ground meshes, complex boundary condition domains and load specifications. The .inp file can be exported from a number of common finite element software such as: FreeCAD or ABAQUS.","category":"page"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"InpStiffness\nInpStiffness(filepath_with_ext::AbstractString; keep_load_cells = false)","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.InputOutput.INP.InpStiffness","page":"TopOptProblems","title":"TopOpt.TopOptProblems.InputOutput.INP.InpStiffness","text":"struct InpStiffness{dim, N, TF, TI, TBool, Tch <: ConstraintHandler, GO, TInds <: AbstractVector{TI}, TMeta<:Metadata} <: StiffnessTopOptProblem{dim, TF}\n    inp_content::InpContent{dim, TF, N, TI}\n    geom_order::Type{Val{GO}}\n    ch::Tch\n    black::TBool\n    white::TBool\n    varind::TInds\n    metadata::TMeta\nend\n\ndim: dimension of the problem\nTF: number type for computations and coordinates\nN: number of nodes in a cell of the grid\ninp_content: an instance of InpContent which stores all the information from the `.inp file.\ngeom_order: a field equal to Val{GO} where GO is an integer representing the order of the finite elements. Linear elements have a geom_order of Val{1} and quadratic elements have a geom_order of Val{2}.\nmetadata: Metadata having various cell-node-dof relationships\nblack: a BitVector of length equal to the number of elements where black[e] is 1 iff the e^th element must be part of the final design\nwhite:  a BitVector of length equal to the number of elements where white[e] is 1 iff the e^th element must not be part of the final design\nvarind: an AbstractVector{Int} of length equal to the number of elements where varind[e] gives the index of the decision variable corresponding to element e. Because some elements can be fixed to be black or white, not every element has a decision variable associated.\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.InputOutput.INP.InpStiffness-Tuple{AbstractString}","page":"TopOptProblems","title":"TopOpt.TopOptProblems.InputOutput.INP.InpStiffness","text":"InpStiffness(filepath::AbstractString; keep_load_cells = false)\n\nImports stiffness problem from a .inp file, e.g. InpStiffness(\"example.inp\"). The keep_load_cells keyword argument will enforce that any cell with a load applied on it is to be part of the final optimal design generated by topology optimization algorithms.\n\n\n\n\n\n","category":"method"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"IO.INP.Parser.InpContent","category":"page"},{"location":"reference/TopOptProblems/#Grids","page":"TopOptProblems","title":"Grids","text":"","category":"section"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"Grid types are defined in TopOptProblems because a number of topology optimization problems share the same underlying grid but apply the loads and boundary conditions at different locations. For example, the PointLoadCantilever and HalfMBB problems use the same rectilinear grid type, RectilinearGrid, under the hood. The LBeam problem uses the LGrid function under the hood to construct an L-shaped Ferrite.Grid. New problem types can be defined using the same grids but different loads or boundary conditions.","category":"page"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"RectilinearGrid\nRectilinearGrid(::Type{Val{CellType}}, nels::NTuple{dim,Int}, sizes::NTuple{dim,T}) where {dim, T, CellType}","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.RectilinearGrid","page":"TopOptProblems","title":"TopOpt.TopOptProblems.RectilinearGrid","text":"struct RectilinearGrid{dim, T, N, M, TG<:Ferrite.Grid{dim, <:Ferrite.Cell{dim,N,M}, T}} <: AbstractGrid{dim, T}\n    grid::TG\n    nels::NTuple{dim, Int}\n    sizes::NTuple{dim, T}\n    corners::NTuple{2, Vec{dim, T}}\n    white_cells::BitVector\n    black_cells::BitVector\n    constant_cells::BitVector\nend\n\nA type that represents a rectilinear grid with corner points corners.\n\ndim: dimension of the problem\nT: number type for computations and coordinates\nN: number of nodes in a cell of the grid\nM: number of faces in a cell of the grid\ngrid: a Ferrite.Grid struct\nnels: number of elements in every dimension\nsizes: dimensions of each rectilinear cell\ncorners: 2 corner points of the rectilinear grid\nwhite_cells: cells fixed to be void during optimization\nblack_cells: cells fixed to have material during optimization\nconstant_cells: cells fixed to be either void or have material during optimization\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.RectilinearGrid-Union{Tuple{CellType}, Tuple{T}, Tuple{dim}, Tuple{Type{Val{CellType}}, Tuple{Vararg{Int64, dim}}, Tuple{Vararg{T, dim}}}} where {dim, T, CellType}","page":"TopOptProblems","title":"TopOpt.TopOptProblems.RectilinearGrid","text":"RectilinearGrid(::Type{Val{CellType}}, nels::NTuple{dim,Int}, sizes::NTuple{dim,T}) where {dim, T, CellType}\n\nConstructs an instance of RectilinearGrid.\n\ndim: dimension of the problem\nT: number type for coordinates\nnels: number of elements in every dimension\nsizes: dimensions of each rectilinear cell\n\nExample:\n\nrectgrid = RectilinearGrid((60,20), (1.0,1.0))\n\n\n\n\n\n","category":"method"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"LGrid","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.LGrid","page":"TopOptProblems","title":"TopOpt.TopOptProblems.LGrid","text":"LGrid(::Type{Val{CellType}}, ::Type{T}; length = 100, height = 100, upperslab = 50, lowerslab = 50) where {T, CellType}\nLGrid(::Type{Val{CellType}}, nel1::NTuple{2,Int}, nel2::NTuple{2,Int}, LL::Vec{2,T}, UR::Vec{2,T}, MR::Vec{2,T}) where {CellType, T}\n\nConstructs a Ferrite.Grid that represents the following L-shaped grid.\n\n        upperslab   UR\n       ............\n       .          .\n       .          .\n       .          . \nheight .          .                     MR\n       .          ......................\n       .                               .\n       .                               . lowerslab\n       .                               .\n       .................................\n     LL             length\n\n\n\nExamples:\n\nLGrid(upperslab = 30, lowerslab = 70)\nLGrid(Val{:Linear}, (2, 4), (2, 2), Vec{2,Float64}((0.0,0.0)), Vec{2,Float64}((2.0, 4.0)), Vec{2,Float64}((4.0, 2.0)))\n\n\n\n\n\n","category":"function"},{"location":"reference/TopOptProblems/#Finite-element-backend","page":"TopOptProblems","title":"Finite element backend","text":"","category":"section"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"Currently, TopOpt uses Ferrite.jl for FEA-related modeling.  This means that all the problems above are described in the language and types of Ferrite.","category":"page"},{"location":"reference/TopOptProblems/#Matrices-and-vectors","page":"TopOptProblems","title":"Matrices and vectors","text":"","category":"section"},{"location":"reference/TopOptProblems/#ElementFEAInfo","page":"TopOptProblems","title":"ElementFEAInfo","text":"","category":"section"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"ElementFEAInfo\nElementFEAInfo(sp, quad_order, ::Type{Val{mat_type}}) where {mat_type}","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.ElementFEAInfo","page":"TopOptProblems","title":"TopOpt.TopOptProblems.ElementFEAInfo","text":"struct ElementFEAInfo{dim, T}\n    Kes::AbstractVector{<:AbstractMatrix{T}}\n    fes::AbstractVector{<:AbstractVector{T}}\n    fixedload::AbstractVector{T}\n    cellvolumes::AbstractVector{T}\n    cellvalues::CellValues{dim, T}\n    facevalues::FaceValues{<:Any, T}\n    metadata::Metadata\n    black::AbstractVector\n    white::AbstractVector\n    varind::AbstractVector{Int}\n    cells\nend\n\nAn instance of the ElementFEAInfo type stores element information such as:\n\nKes: the element stiffness matrices,\nfes: the element load vectors,\ncellvolumes: the element volumes,\ncellvalues and facevalues: two Ferrite types that facilitate cell and face iteration and queries.\nmetadata: that stores degree of freedom (dof) to node mapping, dof to cell mapping, etc.\nblack: a BitVector such that black[i] is 1 iff element i must be part of any feasible design.\nwhite: a BitVector such that white[i] is 1 iff element i must never be part of any feasible design.\nvarind: a vector such that varind[i] gives the decision variable index of element i.\ncells: the cell connectivities.\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.ElementFEAInfo-Union{Tuple{mat_type}, Tuple{Any, Any, Type{Val{mat_type}}}} where mat_type","page":"TopOptProblems","title":"TopOpt.TopOptProblems.ElementFEAInfo","text":"ElementFEAInfo(sp, quad_order=2, ::Type{Val{mat_type}}=Val{:Static}) where {mat_type}\n\nConstructs an instance of ElementFEAInfo from a stiffness problem sp using a Gaussian quadrature order of quad_order. The element matrix and vector types will be:\n\nSMatrix and SVector if mat_type is :SMatrix or :Static, the default,\nMMatrix and MVector if mat_type is :MMatrix, or\nMatrix and Vector otherwise.\n\nThe static matrices and vectors are more performant and GPU-compatible therefore they are used by default.\n\n\n\n\n\n","category":"method"},{"location":"reference/TopOptProblems/#GlobalFEAInfo","page":"TopOptProblems","title":"GlobalFEAInfo","text":"","category":"section"},{"location":"reference/TopOptProblems/","page":"TopOptProblems","title":"TopOptProblems","text":"GlobalFEAInfo\nGlobalFEAInfo(::Type{T}=Float64) where {T}\nGlobalFEAInfo(sp::StiffnessTopOptProblem)","category":"page"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.GlobalFEAInfo","page":"TopOptProblems","title":"TopOpt.TopOptProblems.GlobalFEAInfo","text":"struct GlobalFEAInfo{T, TK<:AbstractMatrix{T}, Tf<:AbstractVector{T}, Tchol}\n    K::TK\n    f::Tf\n    cholK::Tchol\nend\n\nAn instance of GlobalFEAInfo hosts the global stiffness matrix K, the load vector f and the cholesky decomposition of the K, cholK.\n\n\n\n\n\n","category":"type"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.GlobalFEAInfo-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"TopOptProblems","title":"TopOpt.TopOptProblems.GlobalFEAInfo","text":"GlobalFEAInfo(::Type{T}=Float64) where {T}\n\nConstructs an empty instance of GlobalFEAInfo where the field K is an empty sparse matrix of element type T and the field f is an empty dense vector of element type T.\n\n\n\n\n\n","category":"method"},{"location":"reference/TopOptProblems/#TopOpt.TopOptProblems.GlobalFEAInfo-Tuple{StiffnessTopOptProblem}","page":"TopOptProblems","title":"TopOpt.TopOptProblems.GlobalFEAInfo","text":"GlobalFEAInfo(sp::StiffnessTopOptProblem)\n\nConstructs an instance of GlobalFEAInfo where the field K is a sparse matrix with the correct size and sparsity pattern for the problem instance sp. The field f is a dense vector of the appropriate size. The values in K and f are meaningless though and require calling the function assemble! to update.\n\n\n\n\n\n","category":"method"},{"location":"examples/csimp/","page":"Continuous SIMP example","title":"Continuous SIMP example","text":"EditURL = \"https://github.com/JuliaTopOpt/TopOpt.jl/blob/master/docs/src/literate/csimp.jl\"","category":"page"},{"location":"examples/csimp/#Continuous-SIMP-example","page":"Continuous SIMP example","title":"Continuous SIMP example","text":"","category":"section"},{"location":"examples/csimp/","page":"Continuous SIMP example","title":"Continuous SIMP example","text":"tip: Tip\nThis example is also available as a Jupyter notebook: csimp.ipynb","category":"page"},{"location":"examples/csimp/#Commented-Program","page":"Continuous SIMP example","title":"Commented Program","text":"","category":"section"},{"location":"examples/csimp/","page":"Continuous SIMP example","title":"Continuous SIMP example","text":"What follows is a program spliced with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/csimp/","page":"Continuous SIMP example","title":"Continuous SIMP example","text":"using TopOpt","category":"page"},{"location":"examples/csimp/#Define-the-problem","page":"Continuous SIMP example","title":"Define the problem","text":"","category":"section"},{"location":"examples/csimp/","page":"Continuous SIMP example","title":"Continuous SIMP example","text":"E = 1.0 # Young’s modulus\nv = 0.3 # Poisson’s ratio\nf = 1.0 # downward force\n\nproblems = Any[\n    PointLoadCantilever(Val{:Linear}, (60, 20, 20), (1.0, 1.0, 1.0), E, v, f),\n    PointLoadCantilever(Val{:Linear}, (160, 40), (1.0, 1.0), E, v, f),\n    HalfMBB(Val{:Linear}, (60, 20), (1.0, 1.0), E, v, f),\n    LBeam(Val{:Linear}, Float64; force=f),\n    TieBeam(Val{:Quadratic}, Float64),\n]\nproblem_names = [\n    \"3d cantilever beam\", \"cantilever beam\", \"half MBB beam\", \"L-beam\", \"tie-beam\"\n]\n\ni = 2\nprintln(problem_names[i])\nproblem = problems[i]","category":"page"},{"location":"examples/csimp/#Parameter-settings","page":"Continuous SIMP example","title":"Parameter settings","text":"","category":"section"},{"location":"examples/csimp/","page":"Continuous SIMP example","title":"Continuous SIMP example","text":"V = 0.5 # volume fraction\nxmin = 0.001 # minimum density\nrmin = 3.0\n\nconvcriteria = Nonconvex.KKTCriteria()\nx0 = fill(V, TopOpt.getncells(problem))\npenalty = TopOpt.PowerPenalty(1.0)\nsolver = FEASolver(Direct, problem; xmin=xmin, penalty=penalty)\ncomp = Compliance(solver)\nfilter = if problem isa TopOptProblems.TieBeam\n    identity\nelse\n    DensityFilter(solver; rmin=rmin)\nend\nobj = x -> comp(filter(PseudoDensities(x)))","category":"page"},{"location":"examples/csimp/","page":"Continuous SIMP example","title":"Continuous SIMP example","text":"Define volume constraint","category":"page"},{"location":"examples/csimp/","page":"Continuous SIMP example","title":"Continuous SIMP example","text":"volfrac = Volume(solver)\nconstr = x -> volfrac(filter(PseudoDensities(x))) - V\nmodel = Model(obj)\naddvar!(model, zeros(length(x0)), ones(length(x0)))\nadd_ineq_constraint!(model, constr)\nalg = MMA87()\n\nnsteps = 4\nps = range(1.0, 5.0; length=nsteps + 1)","category":"page"},{"location":"examples/csimp/","page":"Continuous SIMP example","title":"Continuous SIMP example","text":"exponentially decaying tolerance from 10^-2 to 10^-4","category":"page"},{"location":"examples/csimp/","page":"Continuous SIMP example","title":"Continuous SIMP example","text":"tols = exp10.(range(-2, -4; length=nsteps + 1))\nx = x0\nfor j in 1:(nsteps + 1)\n    global convcriteria\n    p = ps[j]\n    tol = tols[j]\n    TopOpt.setpenalty!(solver, p)\n    options = MMAOptions(; tol=Tolerance(; kkt=tol), maxiter=1000, convcriteria)\n    res = optimize(model, alg, x; options)\n    global x = res.minimizer\nend\n\n@show obj(x)\n@show constr(x)","category":"page"},{"location":"examples/csimp/#(Optional)-Visualize-the-result-using-Makie.jl","page":"Continuous SIMP example","title":"(Optional) Visualize the result using Makie.jl","text":"","category":"section"},{"location":"examples/csimp/","page":"Continuous SIMP example","title":"Continuous SIMP example","text":"Need to run using Pkg; Pkg.add(Makie) first","category":"page"},{"location":"examples/csimp/","page":"Continuous SIMP example","title":"Continuous SIMP example","text":"using TopOpt.TopOptProblems.Visualization: visualize\nfig = visualize(problem; topology = x, default_exagg_scale = 0.07,\n    scale_range = 10.0, vector_linewidth = 3, vector_arrowsize = 0.5,\n)\nMakie.display(fig)","category":"page"},{"location":"examples/csimp/#csimp-plain-program","page":"Continuous SIMP example","title":"Plain Program","text":"","category":"section"},{"location":"examples/csimp/","page":"Continuous SIMP example","title":"Continuous SIMP example","text":"Below follows a version of the program without any comments. The file is also available here: csimp.jl","category":"page"},{"location":"examples/csimp/","page":"Continuous SIMP example","title":"Continuous SIMP example","text":"using TopOpt\n\nE = 1.0 # Young’s modulus\nv = 0.3 # Poisson’s ratio\nf = 1.0 # downward force\n\nproblems = Any[\n    PointLoadCantilever(Val{:Linear}, (60, 20, 20), (1.0, 1.0, 1.0), E, v, f),\n    PointLoadCantilever(Val{:Linear}, (160, 40), (1.0, 1.0), E, v, f),\n    HalfMBB(Val{:Linear}, (60, 20), (1.0, 1.0), E, v, f),\n    LBeam(Val{:Linear}, Float64; force=f),\n    TieBeam(Val{:Quadratic}, Float64),\n]\nproblem_names = [\n    \"3d cantilever beam\", \"cantilever beam\", \"half MBB beam\", \"L-beam\", \"tie-beam\"\n]\n\ni = 2\nprintln(problem_names[i])\nproblem = problems[i]\n\nV = 0.5 # volume fraction\nxmin = 0.001 # minimum density\nrmin = 3.0\n\nconvcriteria = Nonconvex.KKTCriteria()\nx0 = fill(V, TopOpt.getncells(problem))\npenalty = TopOpt.PowerPenalty(1.0)\nsolver = FEASolver(Direct, problem; xmin=xmin, penalty=penalty)\ncomp = Compliance(solver)\nfilter = if problem isa TopOptProblems.TieBeam\n    identity\nelse\n    DensityFilter(solver; rmin=rmin)\nend\nobj = x -> comp(filter(PseudoDensities(x)))\n\nvolfrac = Volume(solver)\nconstr = x -> volfrac(filter(PseudoDensities(x))) - V\nmodel = Model(obj)\naddvar!(model, zeros(length(x0)), ones(length(x0)))\nadd_ineq_constraint!(model, constr)\nalg = MMA87()\n\nnsteps = 4\nps = range(1.0, 5.0; length=nsteps + 1)\n\ntols = exp10.(range(-2, -4; length=nsteps + 1))\nx = x0\nfor j in 1:(nsteps + 1)\n    global convcriteria\n    p = ps[j]\n    tol = tols[j]\n    TopOpt.setpenalty!(solver, p)\n    options = MMAOptions(; tol=Tolerance(; kkt=tol), maxiter=1000, convcriteria)\n    res = optimize(model, alg, x; options)\n    global x = res.minimizer\nend\n\n@show obj(x)\n@show constr(x)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/csimp/","page":"Continuous SIMP example","title":"Continuous SIMP example","text":"","category":"page"},{"location":"examples/csimp/","page":"Continuous SIMP example","title":"Continuous SIMP example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/geso/","page":"GESO example: HalfMBB Beam","title":"GESO example: HalfMBB Beam","text":"EditURL = \"https://github.com/JuliaTopOpt/TopOpt.jl/blob/master/docs/src/literate/geso.jl\"","category":"page"},{"location":"examples/geso/#GESO-example:-HalfMBB-Beam","page":"GESO example: HalfMBB Beam","title":"GESO example: HalfMBB Beam","text":"","category":"section"},{"location":"examples/geso/","page":"GESO example: HalfMBB Beam","title":"GESO example: HalfMBB Beam","text":"tip: Tip\nThis example is also available as a Jupyter notebook: geso.ipynb","category":"page"},{"location":"examples/geso/#Commented-Program","page":"GESO example: HalfMBB Beam","title":"Commented Program","text":"","category":"section"},{"location":"examples/geso/","page":"GESO example: HalfMBB Beam","title":"GESO example: HalfMBB Beam","text":"What follows is a program spliced with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/geso/","page":"GESO example: HalfMBB Beam","title":"GESO example: HalfMBB Beam","text":"using TopOpt","category":"page"},{"location":"examples/geso/#Define-the-problem","page":"GESO example: HalfMBB Beam","title":"Define the problem","text":"","category":"section"},{"location":"examples/geso/","page":"GESO example: HalfMBB Beam","title":"GESO example: HalfMBB Beam","text":"E = 1.0 # Young’s modulus\nv = 0.3 # Poisson’s ratio\nf = 1.0; # downward force\n\nnels = (160, 40)\nproblem = HalfMBB(Val{:Linear}, nels, (1.0, 1.0), E, v, f)","category":"page"},{"location":"examples/geso/#Define-the-FEA-Solver-and-penalty-functions","page":"GESO example: HalfMBB Beam","title":"Define the FEA Solver and penalty functions","text":"","category":"section"},{"location":"examples/geso/","page":"GESO example: HalfMBB Beam","title":"GESO example: HalfMBB Beam","text":"solver = FEASolver(Direct, problem; xmin=0.01, penalty=TopOpt.PowerPenalty(3.0))","category":"page"},{"location":"examples/geso/#Define-the-compliance-objective-function-and-volume-fraction-constraint","page":"GESO example: HalfMBB Beam","title":"Define the compliance objective function and volume fraction constraint","text":"","category":"section"},{"location":"examples/geso/","page":"GESO example: HalfMBB Beam","title":"GESO example: HalfMBB Beam","text":"comp = Compliance(solver)\nvolfrac = Volume(solver)\nsensfilter = SensFilter(solver; rmin=4.0)\ngeso = GESO(comp, volfrac, 0.5, sensfilter)","category":"page"},{"location":"examples/geso/#Run-optimization","page":"GESO example: HalfMBB Beam","title":"Run optimization","text":"","category":"section"},{"location":"examples/geso/","page":"GESO example: HalfMBB Beam","title":"GESO example: HalfMBB Beam","text":"x0 = ones(length(solver.vars))\nresult = geso(x0)","category":"page"},{"location":"examples/geso/#(Optional)-Visualize-the-result-using-Makie.jl","page":"GESO example: HalfMBB Beam","title":"(Optional) Visualize the result using Makie.jl","text":"","category":"section"},{"location":"examples/geso/","page":"GESO example: HalfMBB Beam","title":"GESO example: HalfMBB Beam","text":"Need to run using Pkg; Pkg.add(Makie) first","category":"page"},{"location":"examples/geso/","page":"GESO example: HalfMBB Beam","title":"GESO example: HalfMBB Beam","text":"using TopOpt.TopOptProblems.Visualization: visualize\nfig = visualize(problem; topology = result.topology)\nMakie.display(fig)","category":"page"},{"location":"examples/geso/#geso-plain-program","page":"GESO example: HalfMBB Beam","title":"Plain Program","text":"","category":"section"},{"location":"examples/geso/","page":"GESO example: HalfMBB Beam","title":"GESO example: HalfMBB Beam","text":"Below follows a version of the program without any comments. The file is also available here: geso.jl","category":"page"},{"location":"examples/geso/","page":"GESO example: HalfMBB Beam","title":"GESO example: HalfMBB Beam","text":"using TopOpt\n\nE = 1.0 # Young’s modulus\nv = 0.3 # Poisson’s ratio\nf = 1.0; # downward force\n\nnels = (160, 40)\nproblem = HalfMBB(Val{:Linear}, nels, (1.0, 1.0), E, v, f)\n\nsolver = FEASolver(Direct, problem; xmin=0.01, penalty=TopOpt.PowerPenalty(3.0))\n\ncomp = Compliance(solver)\nvolfrac = Volume(solver)\nsensfilter = SensFilter(solver; rmin=4.0)\ngeso = GESO(comp, volfrac, 0.5, sensfilter)\n\nx0 = ones(length(solver.vars))\nresult = geso(x0)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/geso/","page":"GESO example: HalfMBB Beam","title":"GESO example: HalfMBB Beam","text":"","category":"page"},{"location":"examples/geso/","page":"GESO example: HalfMBB Beam","title":"GESO example: HalfMBB Beam","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"EditURL = \"https://github.com/JuliaTopOpt/TopOpt.jl/blob/master/docs/src/literate/simp.jl\"","category":"page"},{"location":"examples/simp/#SIMP-example:-Point-Load-Cantilever","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"","category":"section"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"tip: Tip\nThis example is also available as a Jupyter notebook: simp.ipynb","category":"page"},{"location":"examples/simp/#Commented-Program","page":"SIMP example: Point Load Cantilever","title":"Commented Program","text":"","category":"section"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"What follows is a program spliced with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"using TopOpt","category":"page"},{"location":"examples/simp/#Define-the-problem","page":"SIMP example: Point Load Cantilever","title":"Define the problem","text":"","category":"section"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"E = 1.0 # Young’s modulus\nv = 0.3 # Poisson’s ratio\nf = 1.0; # downward force\n\nnels = (30, 10, 10)\nproblem = PointLoadCantilever(Val{:Linear}, nels, (1.0, 1.0, 1.0), E, v, f);\nnothing #hide","category":"page"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"See also the detailed API of PointLoadCantilever:","category":"page"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"TopOpt.TopOptProblems.PointLoadCantilever","category":"page"},{"location":"examples/simp/#TopOpt.TopOptProblems.PointLoadCantilever","page":"SIMP example: Point Load Cantilever","title":"TopOpt.TopOptProblems.PointLoadCantilever","text":"///**********************************\n///*                                *\n///*                                * |\n///*                                * |\n///********************************** v\n\n\n@params struct PointLoadCantilever{dim, T, N, M} <: StiffnessTopOptProblem{dim, T}\n    rect_grid::RectilinearGrid{dim, T, N, M}\n    E::T\n    ν::T\n    ch::ConstraintHandler{<:DofHandler{dim, <:Cell{dim,N,M}, T}, T}\n    force::T\n    force_dof::Integer\n    black::AbstractVector\n    white::AbstractVector\n    varind::AbstractVector{Int}\n    metadata::Metadata\nend\n\ndim: dimension of the problem\nT: number type for computations and coordinates\nN: number of nodes in a cell of the grid\nM: number of faces in a cell of the grid\nrect_grid: a RectilinearGrid struct\nE: Young's modulus\nν: Poisson's ration\nforce: force at the center right of the cantilever beam (positive is downward)\nforce_dof: dof number at which the force is applied\nch: a Ferrite.ConstraintHandler struct\nmetadata: Metadata having various cell-node-dof relationships\nblack: a BitVector of length equal to the number of elements where black[e] is 1 iff the e^th element must be part of the final design\nwhite:  a BitVector of length equal to the number of elements where white[e] is 1 iff the e^th element must not be part of the final design\nvarind: an AbstractVector{Int} of length equal to the number of elements where varind[e] gives the index of the decision variable corresponding to element e. Because some elements can be fixed to be black or white, not every element has a decision variable associated.\n\n\n\n\n\n","category":"type"},{"location":"examples/simp/#Parameter-settings","page":"SIMP example: Point Load Cantilever","title":"Parameter settings","text":"","category":"section"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"V = 0.3 # volume fraction\nxmin = 1e-6 # minimum density\nrmin = 2.0; # density filter radius\nnothing #hide","category":"page"},{"location":"examples/simp/#Define-a-finite-element-solver","page":"SIMP example: Point Load Cantilever","title":"Define a finite element solver","text":"","category":"section"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"penalty = TopOpt.PowerPenalty(3.0)\nsolver = FEASolver(Direct, problem; xmin=xmin, penalty=penalty)","category":"page"},{"location":"examples/simp/#Define-compliance-objective","page":"SIMP example: Point Load Cantilever","title":"Define compliance objective","text":"","category":"section"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"comp = TopOpt.Compliance(solver)\nfilter = DensityFilter(solver; rmin=rmin)\nobj = x -> comp(filter(PseudoDensities(x)))","category":"page"},{"location":"examples/simp/#Define-volume-constraint","page":"SIMP example: Point Load Cantilever","title":"Define volume constraint","text":"","category":"section"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"volfrac = TopOpt.Volume(solver)\nconstr = x -> volfrac(filter(PseudoDensities(x))) - V","category":"page"},{"location":"examples/simp/#Define-subproblem-optimizer","page":"SIMP example: Point Load Cantilever","title":"Define subproblem optimizer","text":"","category":"section"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"x0 = fill(V, length(solver.vars))\nmodel = Model(obj)\naddvar!(model, zeros(length(x0)), ones(length(x0)))\nadd_ineq_constraint!(model, constr)\nalg = MMA87()\nconvcriteria = Nonconvex.KKTCriteria()\noptions = MMAOptions(; maxiter=3000, tol=Nonconvex.Tolerance(; x=1e-3, f=1e-3, kkt=0.001), convcriteria)\nr = optimize(model, alg, x0; options)\n\n@show obj(r.minimizer)","category":"page"},{"location":"examples/simp/#(Optional)-Visualize-the-result-using-Makie.jl","page":"SIMP example: Point Load Cantilever","title":"(Optional) Visualize the result using Makie.jl","text":"","category":"section"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"Need to run using Pkg; Pkg.add(Makie) first","category":"page"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"using TopOpt.TopOptProblems.Visualization: visualize\nfig = visualize(\n    problem; topology = r.minimizer,\n    default_exagg_scale = 0.07, scale_range = 10.0,\n    vector_linewidth = 3, vector_arrowsize = 0.5,\n)\nMakie.display(fig)","category":"page"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"or convert it to a Mesh Need to run using Pkg; Pkg.add(GeometryBasics) first","category":"page"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"import Makie, GeometryBasics\nresult_mesh = GeometryBasics.Mesh(problem, r.minimizer);\nMakie.mesh(result_mesh)","category":"page"},{"location":"examples/simp/#simp-plain-program","page":"SIMP example: Point Load Cantilever","title":"Plain Program","text":"","category":"section"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"Below follows a version of the program without any comments. The file is also available here: simp.jl","category":"page"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"using TopOpt\n\nE = 1.0 # Young’s modulus\nv = 0.3 # Poisson’s ratio\nf = 1.0; # downward force\n\nnels = (30, 10, 10)\nproblem = PointLoadCantilever(Val{:Linear}, nels, (1.0, 1.0, 1.0), E, v, f);\n\nV = 0.3 # volume fraction\nxmin = 1e-6 # minimum density\nrmin = 2.0; # density filter radius\n\npenalty = TopOpt.PowerPenalty(3.0)\nsolver = FEASolver(Direct, problem; xmin=xmin, penalty=penalty)\n\ncomp = TopOpt.Compliance(solver)\nfilter = DensityFilter(solver; rmin=rmin)\nobj = x -> comp(filter(PseudoDensities(x)))\n\nvolfrac = TopOpt.Volume(solver)\nconstr = x -> volfrac(filter(PseudoDensities(x))) - V\n\nx0 = fill(V, length(solver.vars))\nmodel = Model(obj)\naddvar!(model, zeros(length(x0)), ones(length(x0)))\nadd_ineq_constraint!(model, constr)\nalg = MMA87()\nconvcriteria = Nonconvex.KKTCriteria()\noptions = MMAOptions(; maxiter=3000, tol=Nonconvex.Tolerance(; x=1e-3, f=1e-3, kkt=0.001), convcriteria)\nr = optimize(model, alg, x0; options)\n\n@show obj(r.minimizer)\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"","category":"page"},{"location":"examples/simp/","page":"SIMP example: Point Load Cantilever","title":"SIMP example: Point Load Cantilever","text":"This page was generated using Literate.jl.","category":"page"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"","category":"page"},{"location":"#TopOpt.jl-Documentation","page":"Home","title":"TopOpt.jl Documentation","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TopOpt is a topology optimization package written in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nTopOpt is still under development. If you find a bug, or have ideas for improvements, feel free to open an issue or make a pull request on the TopOpt GitHub page.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install TopOpt.jl, run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"add TopOpt\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"To additionally load the visualization submodule of TopOpt, you will need to install Makie.jl using:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg\"add Makie\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"To load the package, use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TopOpt","category":"page"},{"location":"","page":"Home","title":"Home","text":"and to optionally load the visualization sub-module as part of TopOpt, use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TopOpt, Makie","category":"page"}]
}
